
DRRCI <- function(x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,tr=NA,Y=NA,Z=NA,alpha=0.05,altParam=0,refPop=NA,LRT=0,unCond=0){

  method.rr <- "OP"
  if (!is.na(x4[1])) method.rr = "TP"
  if (length(Y)>1)   method.rr = "CO"

  if (!is.na(x1[1])  & length(Y) > 1 ) print("WARNING: You should not provide BOTH a 2x3 table AND disease/treatment/covariates")
  if (!is.na(refPop) & length(Y) > 1 ) print("WARNING: You should not provide BOTH a reference population table AND disease/treatment/covariates")
  if (length(Y) > 1) {if (length(Z)==length(Y) & sum(Z==1)     != length(Y)) Z <-  cbind(1,Z)
  if (length(Z)!=length(Y) & sum(Z[,1]==1) != length(Y)) Z <-  cbind(1,Z)
  if (is.null(colnames(Z))) colnames(Z) <- paste0("Z",c(1:ncol(Z))-1)
  colnames(Z)[1]="Int"}

  init.pa=init.p3=init.p4=init.t=init.tp=init.k=init.b=NA

  if (method.rr != "CO"){
    if (sum(!is.na(n4))==0) n4 <- rep(0,length(x1))
    if (sum(!is.na(x4))==0) x4 <- rep(0,length(x1))

    badStrata1 <- c(1:length(n1))[ifelse(n1==0 | n2==0 | n3==0 | (n4==0 & sum(n4)>0),1,0)==1]
    badStrata2 <- c(1:length(n1))[x3==0]
    if (altParam==0) badStrata <- sort(unique(c(badStrata1,badStrata2)))
    if (altParam==1) badStrata <- badStrata1
    if (length(badStrata) > 0){
      x1 <- x1[-badStrata]
      x2 <- x2[-badStrata]
      x3 <- x3[-badStrata]
      x4 <- x4[-badStrata]
      n1 <- n1[-badStrata]
      n2 <- n2[-badStrata]
      n3 <- n3[-badStrata]
      n4 <- n4[-badStrata]
    }

    if (refPop=="All"      & !is.na(refPop))     nR <- n1+n2+n3+n4
    if (refPop=="Treat"    & !is.na(refPop))     nR <- n1+n2
    if (refPop=="Cont"     & !is.na(refPop))     nR <- n3+n4
    if (refPop=="Opt"      & !is.na(refPop) & method.rr=="OP")   {
      p1.hat  <- sum(x1)/sum(n1)
      p2.hat  <- sum(x2)/sum(n2)
      p3.hat  <- sum(x3)/sum(n3)
      pa.hat  <- (p1.hat+p2.hat)/2
      pie.num <- (pa.hat*(1/n1 + 1/n2) + (0.01+(p1.hat-p2.hat)^2)/(n3*p3.hat))^(-1)
      pie     <- pie.num/sum(pie.num)
      nR      <- pie*sum(n1+n2+n3) }


    if (refPop=="Opt"      & !is.na(refPop) & method.rr=="TP")   {
      print("WARNING: The option refPop=Opt does not work for method.rr=TP; Defaults to refPop=All")
      nR <- n1+n2+n3+n4}



    if (!is.na(refPop)){
      snR <- sum(nR)
      E1 <- sum((nR/n1)*x1)
      E2 <- sum((nR/n2)*x2)
      E3 <- sum((nR/n3)*x3)
      E4 <- sum((nR/n4)*x4)
      n1 <- (snR^2)/sum(nR^2/n1)
      n2 <- (snR^2)/sum(nR^2/n2)
      n3 <- (snR^2)/sum(nR^2/n3)
      n4 <- (snR^2)/sum(nR^2/n4)
      x1 <- n1*E1/snR
      x2 <- n2*E2/snR
      x3 <- n3*E3/snR
      x4 <- n4*E4/snR
    }

    s <- length(x1)
    goodStrata <- c(1:s)[(x1+x2+x3+x4>0) & (x1+x2 > 0 | altParam==1 | method.rr!="OP")]
    if (length(goodStrata) < s) print("WARNING: Dropping strata without any events (or events in treatment)")

    if (s > 1 & length(goodStrata) > 1) {x1 <- x1[goodStrata]
    x2 <- x2[goodStrata]
    x3 <- x3[goodStrata]
    x4 <- x4[goodStrata]
    n1 <- n1[goodStrata]
    n2 <- n2[goodStrata]
    n3 <- n3[goodStrata]
    n4 <- n4[goodStrata]}
    s <- length(x1)




    N       <- n1+n2+n3+n4
    init.pa <- (x1/n1+x2/n2)/2
    init.pa <- ifelse(init.pa < 0.0001,0.0001,ifelse(init.pa > 0.9999,0.9999,init.pa))
    init.p3 <-  x3/n3
    init.p3 <- ifelse(init.p3 < 0.0001,0.0001,ifelse(init.p3 > 0.9999,0.9999,init.p3))
    init.p4 <-  x4/n4
    init.tp <-  (x1/n1)/(x3/n3)+(x2/n2)/(x4/n4)
    init.t  <- sum(N*init.pa)/sum(N*init.p3)
    tr <- Y <- Z <- NA
  }

  if (method.rr == "CO"){
    init.b2 <- log(mean(Y[tr==0],na.rm=T))
    init.b  <- c(ifelse(is.na(init.b2) | init.b2 < -10, -10,init.b2),rep(0,ncol(Z)-1))
    init.k  <- mean(Y[tr!=0],na.rm=T)/exp(init.b[1])
    x1 <- x2 <- x3 <- x4 <- n1 <- n2 <- n3 <- n4 <- NA
  }
  if (method.rr=="OP") init.r  <-  startR.OP(x1,x2,x3,n1,n2,n3)
  if (method.rr=="TP") init.r  <-  startR.TP(x1,x2,x3,x4,n1,n2,n3,n4)
  if (method.rr=="CO") init.r  <-  startR.CO(tr,Z,Y)

  EST <- LB <- UB <- NA
  if ( (sum(x3)>=2 & (sum(x4)>=2 | sum(n4)==0)) | method.rr == "CO" ){
    if (method.rr=="OP") EST <- getEst.OP(init.pa,init.t,init.p3,init.r,x1,x2,x3,n1,n2,n3,altParam,unCond)
    if (method.rr=="TP") EST <- getEst.TP(init.p4,init.tp,init.p3,init.r,x1,x2,x3,x4,n1,n2,n3,n4)
    if (method.rr=="CO") EST <- getEst.CO(init.k,init.b,init.r,Y,Z,tr)
  }
  if ( (sum(x3)==0 | (sum(x4)==0 & sum(n4)>0)) &  method.rr != "CO")  EST     <- 0
  if (!is.na(EST) & LRT==0) LB <- boundR(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=alpha/2,type="LB",altParam=altParam,method.rr=method.rr,unCond=unCond)
  if (!is.na(EST) & LRT==0) UB <- boundR(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=alpha/2,type="UB",altParam=altParam,method.rr=method.rr,unCond=unCond)
  if (!is.na(EST) & LRT==1) try(LB <- boundR.LRT(init.r,x1,x2,x3,x4,n1,n2,n3,n4,Y,Z,tr,init.pa,init.p3,init.p4,init.t,init.tp,init.k,init.b,method.rr=method.rr,altParam=altParam,alpha2=alpha/2,type="LB"))
  if (!is.na(EST) & LRT==1) try(UB <- boundR.LRT(init.r,x1,x2,x3,x4,n1,n2,n3,n4,Y,Z,tr,init.pa,init.p3,init.p4,init.t,init.tp,init.k,init.b,method.rr=method.rr,altParam=altParam,alpha2=alpha/2,type="UB"))

  beta               <- NA
  if (method.rr == "CO"){
    cname              <- colnames(Z)
    if (length(cname)==0) cname <- rep("--",ncol(Z))
    bestEst            <- NA
    try(bestEst           <- getEst.CO(init.k,init.b,init.r,Y,Z,tr,allRes=1))
    if (length(bestEst) > 1){
      lbe               <- length(bestEst)
      III               <- fI.CO(bestEst[lbe],bestEst[1],bestEst[-c(1,lbe)],tr,length(Y),Z)
      SE                <- rep(NA,lbe)
      try(SE            <- sqrt(diag(solve(III)))[-c(1,lbe)])
      betas             <- bestEst[-c(1,lbe)]
      beta              <- data.frame("name"=cname,"betas"=betas,"SE"=SE)
      colnames(beta)    <- c("","Beta","SE")
    }
  }

  list("EST"=EST,"LB"=LB,"UB"=UB,"beta"=beta)
}


####################################################################################################################
#####
#####Minimization routine runs nleqslv, but uses a wrapper to make the output look like rootSolve
#####
####################################################################################################################


nleqslv2 <- function(x,fn,...,positive=FALSE) {
  res <- nleqslv(x,fn,...)
  res$root   <- ifelse(positive==TRUE & res$x < 0, NA,res$x)
  res$f.root <- ifelse(positive==TRUE & res$x < 0, 10,res$fvec)
  res$estim.precis <- sum(abs(res$fvec))
  res}


####################################################################################################################
#####
#####Generates Data
#####
####################################################################################################################


###
### r = (p2 - p1)/p3
###
###Generates a Dataset (3 groups)
###input:
###r:                 difference in relative risks
###pa.s:              average risk in groups w/ drugs
###p3.s:              average risk in groups w/o drugs
###n1.s, n2.s, n3.s:  total number of subjects in each of the three groups (to be split among s strata)

genData.OP   <- function(pa.s,p3.s,r,n1.s,n2.s,n3.s,s=1){
  if (s>1)  tiltb <- seq(0.67,1.33,length.out=s)
  if (s==1) tiltb <- 1
  tilt  <- tiltb/sum(tiltb)
  r2   <- r/2
  pa   <- pa.s*tiltb
  p3   <- p3.s*tiltb
  p1   <- pa - r2*p3
  p2   <- pa + r2*p3
  n1   <- round(n1.s*tilt)
  n2   <- round(n2.s*rev(tilt))
  n3   <- round(rep(round(n3.s/s),s))
  x1   <- rbinom(s,n1,p1)
  x2   <- rbinom(s,n2,p2)
  x3   <- rbinom(s,n3,p3)
  list("x1"=x1,"x2"=x2,"x3"=x3,"n1"=n1,"n2"=n2,"n3"=n3)
}

###
### r = p2/p02 - p1/p01
### t = p2/p02 + p1/p01
###
###Generates a Dataset (4 groups; two control groups)
###input:
###r:                           difference in relative risks
###t:                           sum of vaccine efficacies
###p01.s, p02.s:                risk in each of the control groups
###n1.s, n2.s, n01.s, n02.s:    total number of subjects in each of the four groups (to be split among s strata)

genData.TP   <- function(t.s,r,p01.s,p02.s,n1.s,n2.s,n01.s,n02.s,s=1){
  t    <- rep(t.s,s)
  p1   <- rep(p01.s*(t-r)/2,s)
  p2   <- rep(p02.s*(t+r)/2,s)
  p01  <- rep(p01.s,s)
  p02  <- rep(p02.s,s)
  n1   <- rep(round(n1.s/s),s)
  n2   <- rep(round(n2.s/s),s)
  n01  <- rep(round(n01.s/s),s)
  n02  <- rep(round(n02.s/s),s)
  x1   <- rbinom(s,n1,p1)
  x2   <- rbinom(s,n2,p2)
  x01  <- rbinom(s,n01,p01)
  x02  <- rbinom(s,n02,p02)
  list("x1"=x1,"x2"=x2,"x01"=x01,"x02"=x02,"n1"=n1,"n2"=n2,"n01"=n01,"n02"=n02)
}

###
###p2 = exp(bZ)(k+r/2)
###p1 = exp(bZ)(k-r/2)
###p0 = exp(bZ)
###
###Generates the outcome (Y), the covariates (Z), the treatment status (tr) for the individuals
###input:
###n:         number of subjects
###r:         (see equation above)
###k:         (see equation above)
###b:         a set of coefficients for the covariates
###

genData.CO   <- function(r,k,b,n){
  ncov  <- length(b)-1
  npg   <- round(n/3)
  n2    <- 3*npg
  tr    <- rep(c(0,1,2),each=npg)
  Z     <- matrix(nrow=n2,ncol=ncov+1)
  Z[,1] <- matrix(rep(1,n2),ncol=1)
  for (i in 1:ncov) Z[,i+1]   <- rbinom(n2,1,0.5)
  p    <- exp(Z%*%b)*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))
  Y    <- rbinom(n2,1,p)
  list("Z"=Z,"Y"=Y,"tr"=tr)
}


####################################################################################################################
#####
#####Calculates the negative log-likelihood
#####
####################################################################################################################


###One Control Group:

fL.OP         <- function(t=NA,pa=NA,p3,r,x1,x2,x3,n1,n2,n3)   {
      s    <- length(p3)
      if (sum(!is.na(pa))>0) p1   <- pa   - r*p3/2
      if (sum(!is.na(pa))>0) p2   <- pa   + r*p3/2
      if (sum(!is.na(t))>0)  p1   <- t*p3 - r*p3/2
      if (sum(!is.na(t))>0)  p2   <- t*p3 + r*p3/2
      out  <- NA
      if (sum(p1>=0)==s & sum(p2>=0)==s & sum(p3>=0)==s &
          sum(p1<=1)==s & sum(p2<=1)==s & sum(p3<=1)==s) {p3 <- ifelse(p3==0,0.000001,ifelse(p3==1,0.999999,p3))
                                                          p1 <- ifelse(p1==0,0.000001,ifelse(p1==1,0.999999,p1))
                                                          p2 <- ifelse(p2==0,0.000001,ifelse(p2==1,0.999999,p2))
                                                          out2 <- -(x3*log(p3)+(n3-x3)*log(1-p3)+
                                                                    x1*log(p1)+(n1-x1)*log(1-p1)+
                                                                    x2*log(p2)+(n2-x2)*log(1-p2))
                                                          out  <- sum(out2)}
      if (abs(out)>9999999999999 | is.na(out)) out <- 9999999999999
 out}



###Two Control groups

fL.TP         <- function(t,r,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)   {
      s    <- length(p01)
      p1 <- p01*(t-r)/2
      p2 <- p02*(t+r)/2
      out  <- NA
      if (sum(p1>=0)==s & sum(p2>=0)==s & sum(p01>=0)==s & sum(p02>=0)==s &
          sum(p1<=1)==s & sum(p2<=1)==s & sum(p01<=1)==s & sum(p02<=1)==s) {p01 <- ifelse(p01==0,0.000001,ifelse(p01==1,0.999999,p01))
                                                                            p02 <- ifelse(p02==0,0.000001,ifelse(p02==1,0.999999,p02))
                                                                            p1  <- ifelse(p1==0,0.000001,ifelse(p1==1,0.999999,p1))
                                                                            p2  <- ifelse(p2==0,0.000001,ifelse(p2==1,0.999999,p2))
                                                                            out2 <- -(x02*log(p02)+(n02-x02)*log(1-p02)+
                                                                                      x01*log(p01)+(n01-x01)*log(1-p01)+
                                                                                      x1*log(p1)+(n1-x1)*log(1-p1)+
                                                                                      x2*log(p2)+(n2-x2)*log(1-p2))
                                                                            out  <- sum(out2)}
      if (abs(out)>9999999999999 | is.na(out)) out <- 9999999999999
out}


###Individual-level Covarites

fL.CO         <- function(r,k,b,Y,Z,tr){
  p    <- exp(Z%*%b)*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))
  p    <- ifelse(p<=0,0.000001,ifelse(p>=1,0.999999,p))
  out  <- -sum(Y*log(p)+(1-Y)*log(1-p))
out
}



####################################################################################################################
#####
#####Calculates the score equations (i.e. derivative of the log-likelhood)
#####
####################################################################################################################



###One Control Group: Standard Parameterization

dL.OP1<- function(pa,p3,r,x1,x2,x3,n1,n2,n3)   {
  s   <- length(pa)
  p1=pa-r*p3/2
  p2=pa+r*p3/2
  p1=ifelse(x1>0 & p1==0,0.0001,p1)
  p2=ifelse(x2>0 & p2==0,0.0001,p2)
  p3=ifelse(x3>0 & p3==0,0.0001,p3)
  out.r  <- sum(-x1*(p3/2)/(p1) + (n1-x1)*(p3/2)/(1-p1) +
                 x2*(p3/2)/(p2) - (n2-x2)*(p3/2)/(1-p2))
  out.pa <-      x1[1]/p1[1] - (n1[1]-x1[1])/(1-p1[1])  +
                 x2[1]/p2[1] - (n2[1]-x2[1])/(1-p2[1])
  out.p3 <-      x3[1]/p3[1] - (n3[1]-x3[1])/(1-p3[1])  -  x1[1]*(r/2)/(p1[1]) + (n1[1]-x1[1])*(r/2)/(1-p1[1]) +
                                                           x2[1]*(r/2)/(p2[1]) - (n2[1]-x2[1])*(r/2)/(1-p2[1])
  out    <- c(out.r,out.pa,out.p3)
  if (s > 1) for (i in 2:s) {
    out.pa <-       x1[i]/p1[i] - (n1[i]-x1[i])/(1-p1[i])  +
                    x2[i]/p2[i] - (n2[i]-x2[i])/(1-p2[i])
    out.p3 <-       x3[i]/p3[i] - (n3[i]-x3[i])/(1-p3[i])  -  x1[i]*(r/2)/(p1[i]) + (n1[i]-x1[i])*(r/2)/(1-p1[i]) +
                                                              x2[i]*(r/2)/(p2[i]) - (n2[i]-x2[i])*(r/2)/(1-p2[i])
    out    <- c(out,out.pa,out.p3)

  }
  out <- matrix(out,ncol=1)
out
}

###One Control Group: Alternative Parameterization

dL.OP2<- function(t,p3,r,x1,x2,x3,n1,n2,n3)   {
  s   <- length(p3)
  p1=(t*p3-r*p3/2)
  p2=(t*p3+r*p3/2)
  p1=ifelse(x1>0 & p1==0,0.0001,p1)
  p2=ifelse(x2>0 & p2==0,0.0001,p2)
  p3=ifelse(x3>0 & p3==0,0.0001,p3)
  out.r  <- sum(-x1*p3/(2*p1) + (n1-x1)*p3/(2*(1-p1)) +
                  x2*p3/(2*p2) - (n2-x2)*p3/(2*(1-p2)) )
  out.t <-  sum(x1*p3/p1 - (n1-x1)*p3/(1-p1) +
                     x2*p3/p2 - (n2-x2)*p3/(1-p2) )
  out.p3 <- x3[1]/p3[1] - (n3[1]-x3[1])/(1-p3[1]) + x1[1]*(t-r/2)/p1[1] - (n1[1]-x1[1])*(t-r/2)/(1-p1[1]) +
                                                    x2[1]*(t+r/2)/p2[1] - (n2[1]-x2[1])*(t+r/2)/(1-p2[1])
  out    <- c(out.r,out.t,out.p3)
  if (s > 1) for (i in 2:s) {
    out.p3 <-  x3[i]/p3[i] - (n3[i]-x3[i])/(1-p3[i]) + x1[i]*(t-r/2)/p1[i] - (n1[i]-x1[i])*(t-r/2)/(1-p1[i]) +
                                                       x2[i]*(t+r/2)/p2[i] - (n2[i]-x2[i])*(t+r/2)/(1-p2[i])
    out    <- c(out,out.p3)

  }
  out <- matrix(out,ncol=1)
  out
}


##Two Control Groups:

dL.TP    <- function(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02) {
  s <- length(p01)
  p1 <- p01*(t-r)/2
  p2 <- p02*(t+r)/2
  p01=ifelse(x01>0 & p01==0,0.0001,p01)
  p02=ifelse(x02>0 & p02==0,0.0001,p02)
  p1=ifelse(x1>0 & p1==0,0.0001,p1)
  p2=ifelse(x2>0 & p2==0,0.0001,p2)
  q1 <- 1-p1
  q2 <- 1-p2
  q01<- 1-p01
  q02<- 1-p02
  out.r   <- sum(-x1/(t-r)+(n1-x1)*p01/(2*q1)+x2/(t+r)-(n2-x2)*p02/(2*q2))
  out.t   <- x1[1]/(t[1]-r)-(n1[1]-x1[1])*p01[1]/(2*q1[1])+x2[1]/(t[1]+r)-(n2[1]-x2[1])*p02[1]/(2*q2[1])
  out.P01 <- x01[1]/p01[1]-(n01[1]-x01[1])/q01[1]+x1[1]/p01[1]-(n1[1]-x1[1])*(t[1]-r)/(2*q1[1])
  out.P02 <- x02[1]/p02[1]-(n02[1]-x02[1])/q02[1]+x2[1]/p02[1]-(n2[1]-x2[1])*(t[1]+r)/(2*q2[1])
  out <- c(out.r,out.t,out.P01,out.P02)
  if (s > 1) for (i in 2:s){
    out     <- c(out, x1[i]/(t[i]-r)-(n1[i]-x1[i])*p01[i]/(2*q1[i])+x2[i]/(t[i]+r)-(n2[i]-x2[i])*p02[i]/(2*q2[i]),
                      x01[i]/p01[i]-(n01[i]-x01[i])/q01[i]+x1[i]/p01[i]-(n1[i]-x1[i])*(t[i]-r)/(2*q1[i]),
                      x02[i]/p02[i]-(n02[i]-x02[i])/q02[i]+x2[i]/p02[i]-(n2[i]-x2[i])*(t[i]+r)/(2*q2[i]))
  }
  matrix(out,ncol=1)
  }


####Individual-Level covariates

dL.CO    <- function(r,k,b,tr,n,Z,Y) {
  nc     <- length(b)
  ezb    <- exp(Z%*%b)
  p      <- ezb*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))
  q      <- 1-p
  out.r  <- sum((-Y/(2*(k-r/2)) + (1-Y)*ezb /(2*q))*ifelse(tr==1,1,0) +   (Y/(2*(k+r/2)) - (1-Y)*ezb/(2*q))*ifelse(tr==2,1,0))
  out.k  <- sum( (Y/(  (k-r/2)) - (1-Y)*ezb /(  q))*ifelse(tr==1,1,0) +   (Y/(  (k+r/2)) - (1-Y)*ezb/(  q))*ifelse(tr==2,1,0))
  out    <- c(out.r,out.k)
  for (i in 1:nc) out <- c(out,sum(Y*Z[,i]-(1-Y)*Z[,i]*p/q))
matrix(out,ncol=1)
}


####################################################################################################################
#####
#####Calculates the negative of the information matrices
#####
####################################################################################################################


###One Control Group: Standard Parameterization

fI.OP1   <- function(pa,p3,r,n1,n2,n3){

  r2 <- r/2
  p1 <- pa - r2*p3
  p2 <- pa + r2*p3
  q1 <- 1-p1
  q2 <- 1-p2
  q3 <- 1-p3
  s  <- length(pa)
  prob <- 0
  if(sum(p1<0) > 0 | sum(p1>1) > 0 | sum(p2<0) > 0 | sum(p2>1) > 0) prob <- 1
  sv <- ifelse(prob==0,0,NA)
  I      <- matrix(sv,nrow=(2*s+1),ncol=(2*s+1))
  if (prob==0){
    I[1,1] <- dL2.RR   <- sum(-(n1*(p3/2)^2)/(p1*q1) - (n2*(p3/2)^2)/(p2*q2))
    for (i in 1:s){
      sp <- 2+2*(i-1)
      ep <- sp + 1
      I[ep,ep] <- dL2.P3P3 <- -n3[i]/(p3[i]*q3[i]) - n1[i]*r2^2/(p1[i]*q1[i]) - n2[i]*r2^2/(p2[i]*q2[i])
      I[sp,sp] <- dL2.PAPA <- -n1[i]/(p1[i]*q1[i]) - n2[i]/(p2[i]*q2[i])

      I[sp,ep] <- I[ep,sp] <- dL2.P3PA <-  n1[i]*r2/(p1[i]*q1[i]) - n2[i]*r2/(p2[i]*q2[i])
      I[1,sp]  <- I[sp,1]  <- dL2.PAR  <-  n1[i]*(p3[i]/2)/(p1[i]*q1[i]) - n2[i]*(p3[i]/2)/(p2[i]*q2[i])
      I[1,ep]  <- I[ep,1]  <- dL2.P3R  <- -n1[i]*(pa[i]/2)/p1[i] +
        n1[i]*((1-pa[i])/2)/q1[i] +
        n2[i]*(pa[i]/2)/p2[i] +
        -n2[i]*((1-pa[i])/2)/q2[i]
    }
  }
  return(-I)
}


###One Control Group: Alternative Parameterization

fI.OP2   <- function(t,p3,r,n1,n2,n3){

  r2 <- r/2
  p1 <- t*p3 - r2*p3
  p2 <- t*p3 + r2*p3
  q1 <- 1-p1
  q2 <- 1-p2
  q3 <- 1-p3
  s  <- length(p3)
  prob <- 0
  if(sum(p1<0) > 0 | sum(p1>1) > 0 | sum(p2<0) > 0 | sum(p2>1) > 0) prob <- 1
  sv <- ifelse(prob==0,0,NA)
  I      <- matrix(sv,nrow=(s+2),ncol=(s+2))
  if (prob==0){
    I[1,1] <- dL2.RR   <- sum(-(n1*(p3/2)^2)/(p1*q1) - (n2*(p3/2)^2)/(p2*q2))
    I[2,2] <- dL2.TT   <- sum(-(n1*p3^2)/(p1*q1) - (n2*p3^2)/(p2*q2))
    I[1,2] <- I[2,1]   <- dL2.TR  <-  sum(n1*p3^2/(2*p1*q1) - n2*p3^2/(2*p2*q2))

    for (i in 1:s){
      sp <- 2+i
      I[sp,sp] <- dL2.P3P3 <- -n3[i]/(p3[i]*q3[i]) - n1[i]*(t-r2)^2/(p1[i]*q1[i]) - n2[i]*(t+r2)^2/(p2[i]*q2[i])
      I[1,sp]  <- I[sp,1]  <- dL2.P3R  <-   n1[i]/(2*q1[i]) - n2[i]/(2*q2[i])
      I[2,sp]  <- I[sp,2]  <- dL2.P3T  <-  -n1[i]/q1[i]     - n2[i]/q2[i]
    }
  }
  return(-I)
}

###Two Control Groups:

fI.TP <- function(t,r,p01,p02,n1,n2,n01,n02) {
  p1 <- p01*(t-r)/2
  p2 <- p02*(t+r)/2
  q1 <- 1-p1
  q2 <- 1-p2
  q01<- 1-p01
  q02<- 1-p02
  s  <- length(p1)
  prob <- 0
  if(sum(p1<0) > 0 | sum(p1>1) > 0 | sum(p2<0) > 0 | sum(p2>1) > 0 | sum(p01<0) > 0 | sum(p01>1) > 0 | sum(p02<0) > 0 | sum(p02>1) > 0) prob <- 1
  sv <- ifelse(prob==0,0,NA)
  I      <- matrix(sv,nrow=(3*s+1),ncol=(3*s+1))
  I[1,1]     <- sum(-n1*p01^2/(4*p1*q1) -n2*p02^2/(4*p2*q2))
  I[2,2]     <-  -n1[1]*p01[1]^2/(4*p1[1]*q1[1]) -n2[1]*p02[1]^2/(4*p2[1]*q2[1])
  I[3,3]     <- out.P01P01 <- -n01[1]/(p01[1]*q01[1]) - (n1[1]*(t[1]-r)^2)/(4*p1[1]*q1[1])
  I[4,4]     <- out.P02P02 <- -n02[1]/(p02[1]*q02[1]) - (n1[1]*(t[1]+r)^2)/(4*p2[1]*q2[1])
  I[1,3]     <- I[3,1]     <- out.P01r  <- n1[1]/(2*q1[1])
  I[1,4]     <- I[1,4]     <- out.P02r <- -n2[1]/(2*q2[1])
  I[2,3]     <- I[3,2]     <- out.P01t <- -n1[1]/(2*q1[1])
  I[2,4]     <- I[4,2]     <- out.P02t <- -n2[1]/(2*q2[1])
  I[1,2]     <- I[2,1]     <- out.tr     <- n1[1]*p01[1]^2/(4*p1[1]*q1[1]) -n2[1]*p02[1]^2/(4*p2[1]*q2[1])
  if (s > 1) for (i in 2:s) {
    sv <- (i-1)*3+2
    I[sv,sv]     <-  -n1[i]*p01[i]^2/(4*p1[i]*q1[i]) -n2[i]*p02[i]^2/(4*p2[i]*q2[i])
    I[sv+1,sv+1]     <- out.P01P01 <- -n01[i]/(p01[i]*q01[i]) - (n1[i]*(t[i]-r)^2)/(4*p1[i]*q1[i])
    I[sv+2,sv+2]     <- out.P02P02 <- -n02[i]/(p02[i]*q02[i]) - (n1[i]*(t[i]+r)^2)/(4*p2[i]*q2[i])
    I[1,sv+1]     <- I[sv+1,1]     <- out.P01r  <- n1[i]/(2*q1[i])
    I[1,sv+2]     <- I[sv+2.1]     <- out.P02r <- -n2[i]/(2*q2[i])
    I[2,sv+1]     <- I[sv+1,2]     <- out.P01t <- -n1[i]/(2*q1[i])
    I[2,sv+2]     <- I[sv+2,2]     <- out.P02t <- -n2[i]/(2*q2[i])
    I[1,sv]      <- I[sv,1]     <- out.tr     <- n1[i]*p01[i]^2/(4*p1[i]*q1[i]) -n2[i]*p02[i]^2/(4*p2[i]*q2[i])

  }
-I
}


###Individual-level covariates

fI.CO <- function(r,k,b,tr,n,Z) {
  nc     <- length(b)
  ezb    <- exp(Z%*%b)
  ezb2   <- ezb^2
  p      <- ezb*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))
  q      <- 1-p
  Zmat   <- matrix(nrow=nc,ncol=nc)
  I      <- matrix(nrow=(nc+2),ncol=(nc+2))
  for (i in 1:nc) for (j in 1:nc)  Zmat[i,j] <- sum(-Z[,i]*Z[,j]*p/q)
  I[-c(1,2),-c(1:2)] <- Zmat
  I[2,2]  <- sum((-p/(k-r/2)^2 - ezb2/q)*ifelse(tr==1,1,0) + (-p/(k+r/2)^2 - ezb2/q)*ifelse(tr==2,1,0))
  I[1,1]  <- sum((-p/(4*(k-r/2)^2) - ezb2/(4*q))*ifelse(tr==1,1,0) + (-p/(4*(k+r/2)^2) - ezb2/(4*q))*ifelse(tr==2,1,0))
  I[1,2]  <- I[2,1] <- sum((p/(2*(k-r/2)^2) + ezb2/(2*q))*ifelse(tr==1,1,0) - (p/(2*(k+r/2)^2) + ezb2/(2*q))*ifelse(tr==2,1,0))
  for (i in 1:nc) I[1,i+2] <- I[i+2,1] <- sum(  (Z[,i]*ezb/(2*q))*ifelse(tr==1,1,0) - (Z[,i]*ezb/(2*q))*ifelse(tr==2,1,0))
  for (i in 1:nc) I[2,i+2] <- I[i+2,2] <- -sum( (Z[,i]*ezb/(q))*ifelse(tr==1,1,0)   + (Z[,i]*ezb/(q))*ifelse(tr==2,1,0))
  -I
}


####################################################################################################################
#####
#####Funtions that calculate the log-likelihood or score vectors ... using different formats of input
#####
####################################################################################################################


fL.pap3r         <- function(pap3r,x1,x2,x3,n1,n2,n3,deriv=0) {s <- length(x1)
pa<- pap3r[1:s]
p3<- pap3r[(s+1):(2*s)]
r <- pap3r[2*s+1]
if (deriv==0) out <- fL.OP(NA,pa,p3,r,x1,x2,x3,n1,n2,n3)
if (deriv==1) out <- dL.OP1(pa,p3,r,x1,x2,x3,n1,n2,n3)
out
}


fL.pap3         <- function(pap3,x1,x2,x3,n1,n2,n3,r,deriv=0) {s <- length(x1)
pa<- pap3[1:s]
p3<- pap3[(s+1):(2*s)]
r2=r
if (deriv==0) out <- fL.OP(NA,pa,p3,r2,x1,x2,x3,n1,n2,n3)
if (deriv==1) out <- dL.OP1(pa,p3,r2,x1,x2,x3,n1,n2,n3)[-1]
out
}


fL.pap3.parms <- function(pap3,parms) { s     <- parms[1]
x1    <- parms[2:(s+1)]
x2    <- parms[(s+2):(2*s+1)]
x3    <- parms[(2*s+2):(3*s+1)]
n1    <- parms[(3*s+2):(4*s+1)]
n2    <- parms[(4*s+2):(5*s+1)]
n3    <- parms[(5*s+2):(6*s+1)]
r     <- parms[(6*s+2)]
deriv <- parms[(6*s+3)]
fL.pap3(pap3,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,r=r,deriv=deriv)
}


fL.pap3r.parms <- function(pap3r,parms) { s     <- parms[1]
x1    <- parms[2:(s+1)]
x2    <- parms[(s+2):(2*s+1)]
x3    <- parms[(2*s+2):(3*s+1)]
n1    <- parms[(3*s+2):(4*s+1)]
n2    <- parms[(4*s+2):(5*s+1)]
n3    <- parms[(5*s+2):(6*s+1)]
deriv <- parms[(6*s+2)]
fL.pap3r(pap3r,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,deriv=deriv)
}

fL.pap3r.parms.m5 <- function(pap3r,parms) fL.pap3r.parms(pap3r-c(rep(0,2*parms[1]),5) ,parms)


fL.tp3r         <- function(tp3r,x1,x2,x3,n1,n2,n3,deriv=0) {s <- length(x1)
t <- tp3r[1]
p3<- tp3r[2:(s+1)]
r <- tp3r[s+2]
if (deriv==0) out=fL.OP(t,NA,p3,r,x1,x2,x3,n1,n2,n3)
if (deriv==1) out=dL.OP2(t,p3,r,x1,x2,x3,n1,n2,n3)
out
}

fL.tp3         <- function(tp3,x1,x2,x3,n1,n2,n3,r,deriv=0) {s <- length(x1)
t <- tp3[1]
p3<- tp3[2:(s+1)]
if (deriv==0) out=fL.OP(t,NA,p3,r,x1,x2,x3,n1,n2,n3)
if (deriv==1) out=dL.OP2(t,p3,r,x1,x2,x3,n1,n2,n3)[-1]
out
}


fL.tp3.parms <- function(tp3,parms) { s     <- parms[1]
x1    <- parms[2:(s+1)]
x2    <- parms[(s+2):(2*s+1)]
x3    <- parms[(2*s+2):(3*s+1)]
n1    <- parms[(3*s+2):(4*s+1)]
n2    <- parms[(4*s+2):(5*s+1)]
n3    <- parms[(5*s+2):(6*s+1)]
r     <- parms[(6*s+2)]
deriv <- parms[(6*s+3)]
fL.tp3(tp3,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,r=r,deriv=deriv)
}


fL.tp3r.parms <- function(tp3r,parms) { s     <- parms[1]
x1    <- parms[2:(s+1)]
x2    <- parms[(s+2):(2*s+1)]
x3    <- parms[(2*s+2):(3*s+1)]
n1    <- parms[(3*s+2):(4*s+1)]
n2    <- parms[(4*s+2):(5*s+1)]
n3    <- parms[(5*s+2):(6*s+1)]
deriv <- parms[(6*s+2)]
fL.tp3r(tp3r,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,deriv=deriv)
}
fL.tp3r.parms.m5 <- function(tp3r,parms) fL.tp3r.parms(tp3r-c(rep(0,1+parms[1]),5) ,parms)



fL.tp01p02r         <- function(tp01p02r,x1,x2,x01,x02,n1,n2,n01,n02,deriv=0) {s <- length(x1)
t  <- tp01p02r[1:s]
p01 <- tp01p02r[(s+1):(2*s)]
p02 <- tp01p02r[(2*s+1):(3*s)]
r <- tp01p02r[3*s+1]
if (deriv==0) out <- fL.TP(t,r,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)
if (deriv==1) out <- dL.TP(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)
out
}


fL.tp01p02         <- function(tp01p02,x1,x2,x01,x02,n1,n2,n01,n02,r,deriv=0) {s <- length(x1)
t  <- tp01p02[1:s]
p01 <- tp01p02[(s+1):(2*s)]
p02 <- tp01p02[(2*s+1):(3*s)]
if (deriv==0) out <- fL.TP(t,r,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)
if (deriv==1) out <- dL.TP(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)[-1]
out
}


fL.tp01p02.parms <- function(tp01p02,parms) { s     <- parms[1]
x1    <- parms[2:(s+1)]
x2    <- parms[(s+2):(2*s+1)]
x01    <- parms[(2*s+2):(3*s+1)]
x02    <- parms[(3*s+2):(4*s+1)]
n1    <- parms[(4*s+2):(5*s+1)]
n2    <- parms[(5*s+2):(6*s+1)]
n01    <- parms[(6*s+2):(7*s+1)]
n02    <- parms[(7*s+2):(8*s+1)]
r      <- parms[(8*s+2)]
deriv <- parms[(8*s+3)]
fL.tp01p02(tp01p02,x1,x2,x01,x02,n1,n2,n01,n02,r,deriv)
}


fL.tp01p02r.parms <- function(tp01p02r,parms) {  s     <- parms[1]
x1    <- parms[2:(s+1)]
x2    <- parms[(s+2):(2*s+1)]
x01    <- parms[(2*s+2):(3*s+1)]
x02    <- parms[(3*s+2):(4*s+1)]
n1    <- parms[(4*s+2):(5*s+1)]
n2    <- parms[(5*s+2):(6*s+1)]
n01    <- parms[(6*s+2):(7*s+1)]
n02    <- parms[(7*s+2):(8*s+1)]
deriv <- parms[(8*s+2)]
fL.tp01p02r(tp01p02r,x1,x2,x01,x02,n1,n2,n01,n02,deriv)
}
fL.tp01p02r.parms.m5 <- function(tp01p02r,parms) fL.tp01p02r.parms(tp01p02r-c(rep(0,3*parms[1]),5) ,parms)



fL.kbr         <- function(kbr,Y,Z,tr,deriv=0){
  k <- kbr[1]
  b <- kbr[2:(1+ncol(Z))]
  r <- kbr[(2+ncol(Z))]
  if (deriv==0) out <- fL.CO(r,k,b,Y,Z,tr)
  if (deriv==1) out <- dL.CO(r,k,b,tr,n=length(Y),Z,Y)
  out
}

fL.kb         <- function(kb,Y,Z,tr,r,deriv=0){
  k <- kb[1]
  b <- kb[2:(1+ncol(Z))]
  if (deriv==0) out <- fL.CO(r,k,b,Y,Z,tr)
  if (deriv==1) out <- dL.CO(r,k,b,tr,n=length(Y),Z,Y)[-1]
  out
}


fL.kb.parms <- function(kb,parms) {   n     <- parms[1]
r     <- parms[2]
deriv <- parms[3]
Y     <- parms[(4:(n+3))]
tr    <- parms[(n+4):(2*n+3)]
Z     <- matrix(parms[-c(1:(2*n+3))],byrow=F,nrow=n)
fL.kb(kb,Y,Z,tr,r,deriv)
}


fL.kbr.parms <- function(kbr,parms) {   n     <- parms[1]
deriv <- parms[2]
Y     <- parms[(3:(n+2))]
tr    <- parms[(n+3):(2*n+2)]
Z     <- matrix(parms[-c(1:(2*n+2))],byrow=F,nrow=n)
fL.kbr(kbr,Y,Z,tr,deriv)
}




####################################################################################################################
#####
##### Identifies teh conditional and unconditional MLE
#####
####################################################################################################################



optim.force <-  function(pa=NA,p3=NA,t=NA,r=NA,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr="OP",x1,x2,x3,x4,n1,n2,n3,n4,n,Z,Y,tr,fix.r=0,allRes=0){
  s              <- length(x1)
  if (method.rr=="OP" & altParam==0)  allParam       <- c(pa,p3,r)
  if (method.rr=="OP" & altParam==1)  allParam       <- c(t,p3,r)
  if (method.rr=="CO")                allParam       <- c(k,b,r)
  if (method.rr=="TP")                allParam       <- c(tp,p3,p4,r)

  if (fix.r==0)  nparam <- length(allParam)
  if (fix.r==1)  nparam <- length(allParam)-1

  prevMin <- 99999999999
  mult    <- 1
  out     <- NA
  for (nattempt in 1:1000){
    for (curIndex in 1:nparam){
      if (curIndex <   length(allParam) & method.rr=="OP") poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-0.1*mult,0.0001),min(allParam[curIndex]+0.1*mult,0.9999),length.out=10)))
      if (curIndex ==  length(allParam) & method.rr=="OP") poss.vals <- sort(c(allParam[curIndex],seq    (allParam[curIndex]-0.1*mult,            allParam[curIndex]+0.1*mult,        length.out=10)))
      if (curIndex <   length(allParam) & method.rr=="TP") poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-0.1*mult,0.0001),min(allParam[curIndex]+0.1*mult,0.9999),length.out=10)))
      if (curIndex ==  length(allParam) & method.rr=="TP") poss.vals <- sort(c(allParam[curIndex],seq    (allParam[curIndex]-0.1*mult,            allParam[curIndex]+0.1*mult,        length.out=10)))

      if (curIndex ==  1 & method.rr=="CO")                {  rrr  <- allParam[length(allParam)]
      tlb  <- abs(rrr/2)
      tub  <- min(1/max(exp(Z%*%b)),3)
      poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-2*mult,tlb),min(allParam[curIndex]+2*mult,tub),length.out=10)))}
      if (curIndex >  1 & curIndex <   length(allParam) & method.rr=="CO")                {  rrr  <- allParam[length(allParam)]
      kkk  <- allParam[1]
      bbb  <- allParam[-c(1,curIndex,length(allParam))]
      ppp  <- exp(Z[,-(curIndex-1)]%*%matrix(bbb,ncol=1))*ifelse(tr==1,kkk-rrr/2,ifelse(tr==2,kkk+rrr/2,1))
      tlb  <- max(  ifelse(Z[,(curIndex-1)]<0,log(1/ppp)/Z[,(curIndex-1)],-10^10) )
      tub  <- min(  ifelse(Z[,(curIndex-1)]>0,log(1/ppp)/Z[,(curIndex-1)],10^10) )
      poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-2*mult,tlb),min(allParam[curIndex]+2*mult,tub),length.out=10)))}
      if (curIndex ==  length(allParam) & method.rr=="CO") poss.vals <- sort(c(allParam[curIndex],seq    (allParam[curIndex]-0.1*mult,            allParam[curIndex]+0.1*mult,        length.out=10)))
      npv       <- length(poss.vals)
      func.vals <- matrix(nrow=npv,ncol=1)
      for (i in 1:npv) {allParam[curIndex]=poss.vals[i]
      if (method.rr=="OP" & altParam==0) func.vals[i] <- fL.OP(NA,allParam[1:s],allParam[(s+1):(2*s)],allParam[2*s+1],x1,x2,x3,n1,n2,n3)
      if (method.rr=="OP" & altParam==1) func.vals[i] <- fL.OP2(allParam[1],NA,allParam[(2):(s+1)],allParam[s+2],x1,x2,x3,n1,n2,n3)
      if (method.rr=="CO")               func.vals[i] <- fL.CO(allParam[length(allParam)],allParam[1],allParam[-c(1,length(allParam))],Y,Z,tr)
      if (method.rr=="TP")               func.vals[i] <- fL.TP(allParam[1:s],allParam[length(allParam)],allParam[(s+1):(2*s)],allParam[(2*s+1):(3*s)],x1,x2,x3,x4,n1,n2,n3,n4)
      }
      allParam[curIndex] <-poss.vals[which.min(func.vals)]
    }
    if (method.rr=="OP" & altParam==0) newMin <- fL.OP(NA,allParam[1:s],allParam[(s+1):(2*s)],allParam[2*s+1],x1,x2,x3,n1,n2,n3)
    if (method.rr=="OP" & altParam==1) newMin <- fL.OP(allParam[1],NA,  allParam[(2):(s+1)],  allParam[s+2],  x1,x2,x3,n1,n2,n3)
    if (method.rr=="CO")               newMin <- fL.CO(allParam[length(allParam)],allParam[1],allParam[-c(1,length(allParam))],Y,Z,tr)
    if (method.rr=="TP")               newMin <- fL.TP(allParam[1:s],allParam[length(allParam)],allParam[(s+1):(2*s)],allParam[(2*s+1):(3*s)],x1,x2,x3,x4,n1,n2,n3,n4)
    if (newMin==prevMin) mult <- 0.9*mult
    prevMin <- newMin
    if (mult < 0.001) break
  }
  ok <- ifelse(mult < 0.1,1,0)
  if (mult < 0.1){
    if (method.rr=="OP" & altParam==0 & allRes==0 & fix.r==0) out <- allParam[2*s+1]
    if (method.rr=="OP" & altParam==0 & allRes==0 & fix.r==1) out <- list("pa"=allParam[1:s],"p3"=allParam[(s+1):(2*s)],"r"=allParam[2*s+1],"t"=NA)
    if (method.rr=="OP" & altParam==1 & allRes==0 & fix.r==0) out <- allParam[s+2]
    if (method.rr=="OP" & altParam==1 & allRes==0 & fix.r==1) out <- list("pa"=NA,           "p3"=allParam[(2):(s+1)],  "r"=allParam[s+2],  "t"=allParam[1])
    if (method.rr=="CO"               & allRes==0 & fix.r==0) out <- allParam[length(allParam)]
    if (method.rr=="CO"               & allRes==0 & fix.r==1) out <- list("r"=allParam[length(allParam)],"k"=allParam[1],"b"=allParam[-c(1,length(allParam))])
    if (method.rr=="TP"               & allRes==0 & fix.r==0) out <- allParam[length(allParam)]
    if (method.rr=="TP"               & allRes==0 & fix.r==1) out <- list("tp"=allParam[1:s],"r"=allParam[length(allParam)],"p3"=allParam[(s+1):(2*s)],"p4"=allParam[(2*s+1):(3*s)])


    if (method.rr=="OP" & altParam==0 & allRes==1 & fix.r==1) out <- c(allParam[1:s],allParam[(s+1):(2*s)])
    if (method.rr=="OP" & altParam==0 & allRes==1 & fix.r==0) out <- c(allParam[1:s],allParam[(s+1):(2*s)],allParam[2*s+1])
    if (method.rr=="OP" & altParam==1 & allRes==1 & fix.r==1) out <- c(allParam[1],allParam[(2):(s+1)])
    if (method.rr=="OP" & altParam==1 & allRes==1 & fix.r==0) out <- c(allParam[1],allParam[(2):(s+1)],allParam[s+2])
    if (method.rr=="CO"               & allRes==1 & fix.r==1) out <- allParam[-length(allParam)]
    if (method.rr=="CO"               & allRes==1 & fix.r==0) out <- allParam
    if (method.rr=="TP"               & allRes==1 & fix.r==1) out <- allParam[-length(allParam)]
    if (method.rr=="TP"               & allRes==1 & fix.r==0) out <- allParam

  }
  list("out"=out,"ok"=ok)
}



optim.ideal <- function(pa=NA,p3=NA,t=NA,r=NA,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr="OP",x1,x2,x3,x4,n1,n2,n3,n4,n,Z,Y,tr,fix.r=0,allRes=0){
  s      <- length(x1)
  r.out  <- r
  t.out  <- NA
  pa.out <- rep(NA,s)
  p3.out <- rep(NA,s)
  k.out  <- NA
  b.out  <- rep(NA,length(b))
  p4.out <- rep(NA,s)
  tp.out <- rep(NA,s)
  EST    <- NA
  out    <- NA
  ll.end <- 99999999999
  ok <- 1

  if (method.rr=="OP" & altParam==0){

    if (fix.r==1){
      for (sss in 1:s){
        resb     <- nleqslv2(x=c(pa[sss],p3[sss]),fn=fL.pap3.parms,parms=c(1,x1[sss],x2[sss],x3[sss],n1[sss],n2[sss],n3[sss],r,1),positive=TRUE)
        ll.start <- fL.pap3.parms(c(pa[sss],p3[sss]),parms=c(1,x1[sss],x2[sss],x3[sss],n1[sss],n2[sss],n3[sss],r,0))
        try(ll.end   <- fL.pap3.parms(resb$root,         parms=c(1,x1[sss],x2[sss],x3[sss],n1[sss],n2[sss],n3[sss],r,0)),silent=TRUE)
        if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0
        if (ok==1) pa.out[sss]  <- resb$root[1]
        if (ok==1) p3.out[sss]  <- resb$root[2]
        if (ok==1)             out <- list("pa"=pa.out,"p3"=p3.out)
        if (ok==1 & allRes==1) out <- c(pa.out,p3.out)
      }
    }

    if (fix.r==0){
      resb      <- nleqslv2(x=c(pa,p3,r+5),fn=fL.pap3r.parms.m5,parms=c(length(x1),x1,x2,x3,n1,n2,n3,1),positive=TRUE)
      ll.start  <- fL.pap3r.parms.m5(c(pa,p3,r+5),parms=c(length(x1),x1,x2,x3,n1,n2,n3,0))
      try(ll.end    <- fL.pap3r.parms.m5(resb$root,   parms=c(length(x1),x1,x2,x3,n1,n2,n3,0)),silent=TRUE)
      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0
      if (ok==1)             out  <- resb$root[2*s+1] -5
      if (allRes==1 & ok==1) out  <- resb$root - c(rep(0,2*s),5)
    }

  }


  if (method.rr=="OP" & altParam==1){

    if (fix.r==1){
      resb     <- nleqslv2(x=c(t,p3),fn=fL.tp3.parms,parms=c(s,x1,x2,x3,n1,n2,n3,r,1),positive=TRUE)
      ll.start <- fL.tp3.parms(c(t,p3),  parms=c(s,x1,x2,x3,n1,n2,n3,r,0))
      try(ll.end   <- fL.tp3.parms(resb$root,parms=c(s,x1,x2,x3,n1,n2,n3,r,0)),silent=TRUE)
      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0
      if (ok==1) t.out   <- resb$root[1]
      if (ok==1) p3.out  <- resb$root[-1]
      if (ok==1)             out <- list("t"=t.out,"p3"=p3.out)
      if (ok==1 & allRes==1) out <- c(t.out,p3.out)
    }

    if (fix.r==0){
      resb      <- nleqslv2(x=c(t,p3,r+5),fn=fL.tp3r.parms.m5,parms=c(length(x1),x1,x2,x3,n1,n2,n3,1),positive=TRUE)
      ll.start  <- fL.tp3r.parms.m5(c(t,p3,r+5),parms=c(length(x1),x1,x2,x3,n1,n2,n3,0))
      try(ll.end    <- fL.tp3r.parms.m5(resb$root,   parms=c(length(x1),x1,x2,x3,n1,n2,n3,0)),silent=TRUE)
      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0
      if (ok==1)             out  <- resb$root[s+2]-5
      if (allRes==1 & ok==1) out <- resb$root - c(rep(0,s+1),5)
    }

  }


  if (method.rr=="CO"){

    if (fix.r==1){
      resb     <- nleqslv2(x=c(k,b),fn=fL.kb.parms,parms=c(length(Y),r,1,Y,tr,c(Z)))
      ll.start <- fL.kb.parms(c(k,b),  parms=c(length(Y),r,0,Y,tr,c(Z)))
      try(ll.end   <- fL.kb.parms(resb$root,parms=c(length(Y),r,0,Y,tr,c(Z))),silent=TRUE)
      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0
      if (ok==1) k.out   <- resb$root[1]
      if (ok==1) b.out  <- resb$root[-1]
      if (ok==1)             out <- list("k"=k.out,"b"=b.out)
      if (ok==1 & allRes==1) out <- c(k.out,b.out)
    }

    if (fix.r==0){
      resb      <- nleqslv2(x=c(k,b,r),fn=fL.kbr.parms,parms=c(length(Y),1,Y,tr,c(Z)))
      ll.start  <- fL.kbr.parms(c(k,b,r),parms=c(length(Y),0,Y,tr,c(Z)))
      try(ll.end    <- fL.kbr.parms(resb$root,   parms=c(length(Y),0,Y,tr,c(Z))),silent=TRUE)
      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0
      if (ok==1)             out  <- resb$root[length(c(k,b))+1]
      if (allRes==1 & ok==1) out <- resb$root
    }

  }

  if (method.rr=="TP"){

    if (fix.r==1){
      for (sss in 1:s){
        resb     <- nleqslv2(x=c(tp[sss],p3[sss],p4[sss]),fn=fL.tp01p02.parms,parms=c(1,x1[sss],x2[sss],x3[sss],x4[sss],n1[sss],n2[sss],n3[sss],n4[sss],r,1),positive=TRUE)
        ll.start <- fL.tp01p02.parms(c(tp[sss],p3[sss],p4[sss]),parms=c(1,x1[sss],x2[sss],x3[sss],x4[sss],n1[sss],n2[sss],n3[sss],n4[sss],r,0))
        try(ll.end   <- fL.tp01p02.parms(resb$root,         parms=c(1,x1[sss],x2[sss],x3[sss],x4[sss],n1[sss],n2[sss],n3[sss],n4[sss],r,0)),silent=TRUE)
        if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0
        if (ok==1) tp.out[sss]  <- resb$root[1]
        if (ok==1) p3.out[sss]  <- resb$root[2]
        if (ok==1) p4.out[sss]  <- resb$root[3]
        if (ok==1)             out <- list("tp"=tp.out,"p3"=p3.out,"p4.out"=p4.out)
        if (ok==1 & allRes==1) out <- c(tp.out,p3.out,p4.out)
      }
    }

    if (fix.r==0){
      resb      <- nleqslv2(x=c(tp,p3,p4,r+5),fn=fL.tp01p02r.parms.m5,parms=c(length(x1),x1,x2,x3,x4,n1,n2,n3,n4,1),positive=TRUE)
      ll.start  <- fL.tp01p02r.parms.m5(c(tp,p3,p4,r+5),parms=c(length(x1),x1,x2,x3,x4,n1,n2,n3,n4,0))
      try(ll.end    <- fL.tp01p02r.parms.m5(resb$root,   parms=c(length(x1),x1,x2,x3,x4,n1,n2,n3,n4,0)),silent=TRUE)
      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0
      if (ok==1)             out  <- resb$root[3*s+1] -5
      if (allRes==1 & ok==1) out  <- resb$root - c(rep(0,3*s),5)
    }

  }


  list("out"=out,"ok"=ok)
}

optim.DSS <- function(pa=NA,p3=NA,t=NA,r=NA,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr="OP",x1,x2,x3,x4,n1,n2,n3,n4,n,Z,Y,tr,fix.r=0,allRes=0){
  optim.out <- optim.ideal(pa=pa,p3=p3,t=t,r=r,k=k,b=b,p4=p4,tp=tp,altParam=altParam,method.rr=method.rr,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,n=n,Z=Z,Y=Y,tr=tr,fix.r=fix.r,allRes=allRes)
  if (optim.out$ok==0) optim.out <- optim.force(pa=pa,p3=p3,t=t,r=r,k=k,b=b,p4=p4,tp=tp,altParam=altParam,method.rr=method.rr,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,n=n,Z=Z,Y=Y,tr=tr,fix.r=fix.r,allRes=allRes)
  optim.out$out
}



####################################################################################################################
#####
##### Wrapper functions for finding the conditional MLE
#####
####################################################################################################################



opt.OP1 <- function(r,pa.start,p3.start,x1,x2,x3,n1,n2,n3,forceRoot=0,allRes=0){
  optim.DSS(pa=pa.start,p3=p3.start,t=NA,r=r,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr="OP",x1,x2,x3,x4=rep(0,length(x3)),n1,n2,n3,n4=rep(0,length(x3)),n=NA,Z=NA,Y=NA,tr=NA,fix.r=1,allRes=allRes)
}


opt.OP2 <- function(r,t.start,p3.start,x1,x2,x3,n1,n2,n3,forceRoot=0,allRes=0){
  optim.DSS(pa=NA,p3=p3.start,t=t.start,r=r,k=NA,b=NA,p4=NA,tp=NA,altParam=1,method.rr="OP",x1,x2,x3,x4=rep(0,length(x3)),n1,n2,n3,n4=rep(0,length(x3)),n=NA,Z=NA,Y=NA,tr=NA,fix.r=1,allRes=allRes)
}


opt.TP <- function(r,t.start,p01.start,p02.start,x1,x2,x01,x02,n1,n2,n01,n02,allRes=0){
  optim.DSS(pa=NA,p3=p01.start,t=NA,r=r,k=NA,b=NA,p4=p02.start,tp=t.start,altParam=0,method.rr="TP",x1,x2,x01,x02,n1,n2,n01,n02,n=NA,Z=NA,Y=NA,tr=NA,fix.r=1,allRes=allRes)
}



opt.CO <- function(r,k.start,b.start,tr,Z,Y,allRes=0){
  optim.DSS(pa=NA,p3=NA,t=NA,r=r,k=k.start,b=b.start,p4=NA,tp=NA,altParam=0,method.rr="CO",NA,NA,NA,NA,NA,NA,NA,NA,n=length(Y),Z=Z,Y=Y,tr=tr,fix.r=1,allRes=allRes)
}




####################################################################################################################
#####
#####Wrapper function for getting the uncondition MLE of r
#####
####################################################################################################################


getEst.OP <- function(init.pa=NA,init.t=NA,init.p3,init.r,x1,x2,x3,n1,n2,n3,altParam=0,unCond=0,allRes=0,forceRoot=0){
  optim.DSS(pa=init.pa,p3=init.p3,t=init.t,r=init.r,k=NA,b=NA,p4=NA,tp=NA,altParam=altParam,method.rr="OP",x1,x2,x3,x4=rep(0,length(x3)),n1,n2,n3,n4=rep(0,length(x3)),n=NA,Z=NA,Y=NA,tr=NA,fix.r=0,allRes=allRes)
}

getEst.TP <- function(init.p4,init.tp,init.p3,init.r,x1,x2,x3,x4,n1,n2,n3,n4,allRes=0){
  optim.DSS(pa=NA,p3=init.p3,t=NA,r=init.r,k=NA,b=NA,p4=init.p4,tp=init.tp,altParam=0,method.rr="TP",x1,x2,x3,x4,n1,n2,n3,n4,n=NA,Z=NA,Y=NA,tr=NA,fix.r=0,allRes=allRes)
}


getEst.CO <- function(init.k,init.b,init.r,Y,Z,tr,allRes=0){
  optim.DSS(pa=NA,p3=NA,t=NA,r=init.r,k=init.k,b=init.b,p4=NA,tp=NA,altParam=0,method.rr="CO",NA,NA,NA,NA,NA,NA,NA,NA,n=length(Y),Z=Z,Y=Y,tr=tr,fix.r=0,allRes=allRes)
}


####################################################################################################################
#####
#####Calculates the Z statistic for a given set of values
#####
####################################################################################################################


getZ2.OP1 <- function(pa,p3,r,x1,x2,x3,n1,n2,n3,unCond=0){
I   <- fI.OP1(pa,p3,r,n1,n2,n3)
dL  <- dL.OP1(pa,p3,r,x1,x2,x3,n1,n2,n3)
Z   <- -9999999
if (!is.na(I[1,1])){
  si  <- solve(I[-1,-1])
  if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]
  if (unCond==1) v   <- I[1,1]
  if (v>0 & unCond==0)  Z   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)
  if (v>0 & unCond==1)  Z   <- (dL[1])/sqrt(v)
}
Z
}

getZ2.OP2 <- function(t,p3,r,x1,x2,x3,n1,n2,n3,unCond=0){
  I   <- fI.OP2(t,p3,r,n1,n2,n3)
  dL  <- dL.OP2(t,p3,r,x1,x2,x3,n1,n2,n3)
  Z   <- -9999999
  if (!is.na(I[1,1])){
    si  <- solve(I[-1,-1])
    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]
    if (unCond==1) v   <- I[1,1]
    if (v>0 & unCond==0)  Z   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)
    if (v>0 & unCond==1)  Z   <- (dL[1])/sqrt(v)
  }
  Z
}

getZ2.TP <- function(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02,unCond=0){
  I   <- fI.TP(t,r,p01,p02,n1,n2,n01,n02)
  dL  <- dL.TP(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)
  Z   <- -9999999
  if (!is.na(I[1,1])){
    si  <- solve(I[-1,-1])
    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]
    if (unCond==1) v   <- I[1,1]
    if (v>0 & unCond==0)  Z   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)
    if (v>0 & unCond==1)  Z   <- (dL[1])/sqrt(v)
  }
  Z
}

getZ2.CO <- function(r,k,b,tr,Z,Y,unCond=0) {
  n <- length(Y)
  I   <- fI.CO(r,k,b,tr,n,Z)
  dL  <- dL.CO(r,k,b,tr,n,Z,Y)
  Z2   <- -9999999
  if (!is.na(I[1,1])){
    si  <- solve(I[-1,-1])
    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]
    if (unCond==1) v   <- I[1,1]
    if (v>0 & unCond==0)  Z2   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)
    if (v>0 & unCond==1)  Z2   <- (dL[1])/sqrt(v)
  }
  Z2
}


####################################################################################################################
#####
#####Calculates Z values for a given value r (using MLE of other parameters)
#####
####################################################################################################################


getZ.OP1 <- function(r,x1,x2,x3,n1,n2,n3,unCond=0,forceRoot=0){
  sv  <- startVals.OP(x1,x2,x3,n1,n2,n3,r)
  sv2 <- opt.OP1(r,sv$pa,sv$p3,x1,x2,x3,n1,n2,n3,forceRoot=forceRoot)
  getZ2.OP1(sv2$pa,sv2$p3,r,x1,x2,x3,n1,n2,n3,unCond)
}


getZ.OP2 <- function(r,x1,x2,x3,n1,n2,n3,unCond=0,forceRoot=0){
  sv  <- startVals.OP(x1,x2,x3,n1,n2,n3,r)
  sv2 <- opt.OP2(r,sv$t,sv$p3,x1,x2,x3,n1,n2,n3,forceRoot=forceRoot)
  getZ2.OP2(sv2$t,sv2$p3,r,x1,x2,x3,n1,n2,n3,unCond)
}

getZ.TP <- function(r,x1,x2,x01,x02,n1,n2,n01,n02,unCond=0){
  sv  <- startVals.TP(x1,x2,x01,x02,n1,n2,n01,n02,r)
  sv2 <- opt.TP(r,sv$t,sv$p01,sv$p02,x1,x2,x01,x02,n1,n2,n01,n02)
  getZ2.TP(r,sv2$t,sv2$p01,sv2$p02,x1,x2,x01,x02,n1,n2,n01,n02,unCond)
}

getZ.CO <- function(r,tr,Z,Y,unCond=0){
  sv  <- startVals.CO(r,tr,Z,Y)
  sv2 <- opt.CO(r,sv$k,sv$b,tr,Z,Y)
  getZ2.CO(r,sv2$k,sv2$b,tr,Z,Y,unCond)
}

getZ.OP <- function(r,x1,x2,x3,n1,n2,n3,altParam=0,unCond=0,forceRoot=0){
  if (altParam==0) Z <- getZ.OP1(r,x1,x2,x3,n1,n2,n3,unCond,forceRoot=forceRoot)
  if (altParam==1) Z <- getZ.OP2(r,x1,x2,x3,n1,n2,n3,unCond,forceRoot=forceRoot)
  Z
}



####################################################################################################################
#####
#####Gets good starting values for the nuicance parametyers given a specified value of r
#####
####################################################################################################################


####Given a specific value of r, generate a set of starting values for the MLE for pa and p3
####
startVals2.OP <- function(x1,x2,x3,n1,n2,n3,r){
  if (x1+x2+x3==0) x3 <- x3+1
  d0 <- r*(x3/n3)
  L1 <- (x1*d0-n1-n2-2*x1)*d0+x1+x2
  L2 <- (n1+n2+x1)*d0-n1-n2-x1-x2
  L3 <- n1+n2
  L0 <- x1*d0*(1-d0)
  C  <- L2^3/(27*L3^3)-L1*L2/(6*L3^2)+L0/(2*L3)
  B  <- sign(C)*sqrt(L2^2/(9*L3^2)-L1/(3*L3))
  A  <- (1/3)*(pi+acos(C/B^3))
  p1.t <- 2*B*cos(A)-L2/(3*L3)
  p2.t <- p1.t+d0
  pa=(p1.t+p2.t)/2
  p3=x3/n3
  p3 <- ifelse(p3<0.0001,0.0001,p3)
  if (pa < 0) pa <- (x1+x2)/(n1+n2)
  t=pa/p3
  list("pa"=pa,"p3"=p3,"t"=t)
}

startVals.OP <- function(x1,x2,x3,n1,n2,n3,r){
  s  <- length(x1)
  sv <- startVals2.OP(x1[1],x2[1],x3[1],n1[1],n2[1],n3[1],r)
  pa <- sv$pa
  p3 <- sv$p3
  if (s > 1) for (i in 2:s) { sv <- startVals2.OP(x1[i],x2[i],x3[i],n1[i],n2[i],n3[i],r)
  pa <- c(pa,sv$pa)
  p3 <- c(p3,sv$p3)}
  p3 <- ifelse(p3<0.0001,0.0001,p3)
  p1 <- pa - (r/2)*p3
  p2 <- pa + (r/2)*p3

  thresh.p <- 0.00001
  thresh.p2<- 0.99999

  p1 <- ifelse(p1 < thresh.p,thresh.p,p1)
  p2 <- ifelse(p1==thresh.p,p1 + r*p3,p2)
  p2 <- ifelse(p2 < thresh.p,thresh.p,p2)
  p1 <- ifelse(p2==thresh.p,p2 - r*p3,p1)

  p1 <- ifelse(p1 > thresh.p2,thresh.p2,p1)
  p2 <- ifelse(p1==thresh.p2, p1 + r*p3,p2)
  p2 <- ifelse(p2 > thresh.p2,thresh.p2,p2)
  p1 <- ifelse(p2==thresh.p2, p2 - r*p3,p1)
  pa <- (p1 + p2)/2

  N <- n1+n2+n3
  t <- sum(N*((pa-p3*r/2 + pa+p3*r/2 )/2))/sum(N*p3)


  list("pa"=pa,"p3"=p3,"t"=t)
}


startVals.TP <- function(x1,x2,x01,x02,n1,n2,n01,n02,r){
  sv <- startVals.OP(x1,x2,x3=(x01+x02),n1,n2,n3=(n01+n02),r)
  pcomb <- (x01+x02)/(n01+n02)
  p2 <- (sv$pa+r*sv$p3/2) * ((x02/n02)/pcomb)
  p1 <- (sv$pa-r*sv$p3/2) * ((x01/n01)/pcomb)
  p01 <- (x01/n01)
  p02 <- (x02/n02)
  t   <- p1/p01+p2/p02
  list("p01"=p01,"p02"=p02,"t"=t)
}

startVals.CO <- function(r,tr,Z,Y){
  sv <- -10
  if (sum(Y[tr==0])>0) sv <- log(sum(Y[tr==0])/sum(tr==0))
  b <- c(sv,rep(0,ncol(Z)-1))
  k <- (sum(Y[tr!=0])/sum(tr!=0))/(sum(Y[tr==0])/sum(tr==0))
list("k"=k,"b"=b)
}


####################################################################################################################
#####
#####Identifies good starting values of r
#####
####################################################################################################################


startR.OP <- function(x1,x2,x3,n1,n2,n3){
  ###Option 1: Taylor Series Expansion
  p1       <- sum(x1)/sum(n1) + 0.00001
  p2       <- sum(x2)/sum(n2) + 0.00001
  p3       <- sum(x3)/sum(n3) + 0.00001
  v        <- (p1*(1-p1)/n1 + p2*(1-p2)/n2)/p3^2 + ((p1-p2)^2/(p3^4))*(p3*(1-p3)/n3)
  v2       <- 0.25*(1/p3)^4*(p3*(1-p3)/n3)*p1*(1-p1)/n1 + 0.25*(1/p3)^4*(p3*(1-p3)/n3)*p2*(1-p2)/n2 + (1/p3)^6*((p1-p2)^2)*2*(p3*(1-p3)/n3)^2
  v3       <- v + v2
  rs       <- ((x2+0.5/n2)/(n2+0.5/n2) - (x1+0.5/n1)/(n1+0.5/n1))/((x3+0.5/n3)/(n3+0.5/n3))
  out      <- sum(rs[x3>0]/v3[x3>0])/sum(1/v3[x3>0])
  if (is.na(out)) out <- 0
  out
}

startR.TP <- function(x1,x2,x3,x4,n1,n2,n3,n4){
  ###Option 1: Taylor Series Expansion
  p1       <- sum(x1)/sum(n1) + 0.00001
  p2       <- sum(x2)/sum(n2) + 0.00001
  p3       <- sum(x3)/sum(n3) + 0.00001
  p4       <- sum(x4)/sum(n4) + 0.00001
  v        <- (p1*(1-p1)/n1)/p3^2 + (p2*(1-p2)/n2)/p4^2 + (p1^2/p3^4)*(p3*(1-p3)/n3) + (p2^2/p4^4)*(p4*(1-p4)/n4)
  rs       <- ((x2+0.5/n2)/(n2+0.5/n2))/((x4+0.5/n4)/(n4+0.5/n4)) - ((x1+0.5/n1)/(n1+0.5/n1))/((x3+0.5/n3)/(n3+0.5/n3))
  out      <- sum(rs[x3>0]/v[x3>0])/sum(1/v[x3>0])
  if (is.na(out)) out <- 0
  out
}

startR.CO <- function(tr,Z,Y){
  p1 <- mean(Y[tr==1],na.rm=T)
  p2 <- mean(Y[tr==2],na.rm=T)
  p3 <- mean(Y[tr==0],na.rm=T)
  out <- (p2-p1)/p3
  if (is.na(out) | p3==0) out <- 0
  out
}


####################################################################################################################
#####
##### Identifies the bounds for the score-based confidence intervals
#####
####################################################################################################################


####Find the value of r that gives a z statistic that equals qnorm(alpha2) or qnorm(1-alpha2)
####
findR.int <- function(r,alpha2,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,altParam=0,method.rr="OP",unCond=0)    {if (method.rr=="OP") out <- abs(    abs(getZ.OP(r,x1,x2,x3,n1,n2,n3,altParam,unCond,forceRoot=1)) - abs(qnorm(alpha2))  )
                                                                                                      if (method.rr=="TP") out <- abs(    abs(getZ.TP(r,x1,x2,x3,x4,n1,n2,n3,n4,unCond,forceRoot=1))    - abs(qnorm(alpha2))  )
                                                                                                      if (method.rr=="CO") out <- abs(    abs(getZ.CO(r,tr,Z,Y,unCond))    - abs(qnorm(alpha2))  )
                                                                                                      out}

boundR2    <- function(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=0.025,type="UB",altParam=0,method.rr="OP",unCond=0)   {
                                                                                                       if (type=="UB") min.r    <- EST+0.001
                                                                                                       if (type=="UB") max.r    <- EST+2
                                                                                                       if (type=="UB") start.r  <- min.r
                                                                                                       if (type=="UB") last.r   <- max.r
                                                                                                       if (type=="LB") min.r    <- EST-2
                                                                                                       if (type=="LB") max.r    <- EST-0.001
                                                                                                       if (type=="LB") start.r  <- max.r
                                                                                                       if (type=="LB") last.r   <- min.r
                                                                                                       poss.r  <- seq(start.r,last.r,by=ifelse(type=="LB",-1,1)*0.01)
                                                                                                       poss.d  <- matrix(NA,ncol=1,nrow=length(poss.r))
                                                                                                       for (i in 1:length(poss.r)) {
                                                                                                          aaa=try(poss.d[i] <- findR.int(r=poss.r[i],alpha2=alpha2,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,tr=tr,Z=Z,Y=Y,altParam=altParam,method.rr=method.rr,unCond=unCond),silent=TRUE)
                                                                                                          if (i > 1) if ((poss.d[i] > poss.d[i-1] & poss.d[i] < 1) | is.na(poss.d[i]) | class(aaa) == "try-error") break
                                                                                                       }
                                                                                                       reachMax <- ifelse(i==length(poss.r),1,0)
                                                                                                       poss.r   <- seq(poss.r[i-1],poss.r[i],by=ifelse(type=="LB",-1,1)*0.001)
                                                                                                       poss.d   <- matrix(ncol=1,nrow=length(poss.r))
                                                                                                       for (i in 1:length(poss.r)) {
                                                                                                         aaa=try(poss.d[i] <- findR.int(r=poss.r[i],alpha2=alpha2,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,tr=tr,Z=Z,Y=Y,altParam=altParam,method.rr=method.rr,unCond=unCond),silent=TRUE)
                                                                                                         if (i > 1) if (poss.d[i] > poss.d[i-1] | is.na(poss.d[i]) | class(aaa) == "try-error") break
                                                                                                       }
                                                                                                       out <- ifelse(reachMax==1 | poss.d[i-1] > 0.1,NA,poss.r[i])
out}


boundR    <- function(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=0.025,type="UB",altParam=0,method.rr="TP",unCond=0)  {
      out <- boundR2(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=alpha2,type=type,altParam=altParam,method.rr=method.rr,unCond=unCond)
out
}

####################################################################################################################
#####
##### Identifies the bounds for the likelihood-based confidence intervals
#####
####################################################################################################################


boundR.LRT <- function(init.r=NA,x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,Y=NA,Z=NA,tr=NA,init.pa=NA,init.p3=NA,init.p4=NA,init.t=NA,init.tp=NA,init.k=NA,init.b=NA,method.rr="OP",altParam=0,alpha2=alpha/2,type="LB"){


  comp        <- function(r=NA,x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,Y=NA,Z=NA,tr=NA,s=NA,EST.1=NA,init.pa=NA,init.p3=NA,init.p4=NA,init.t=NA,init.tp=NA,init.k=NA,init.b=NA,method.rr="OP",altParam=0) {
    if (method.rr=="OP" & altParam==0) EST.2     <- opt.OP1(r,init.pa,init.p3,x1,x2,x3,n1,n2,n3,forceRoot=1,allRes=1)
    if (method.rr=="OP" & altParam==1) EST.2     <- opt.OP2(r,init.t,init.p3,x1,x2,x3,n1,n2,n3,forceRoot=1,allRes=1)
    if (method.rr=="TP")               EST.2     <- opt.TP(r,init.t,init.p3,init.p4,x1,x2,x3,x4,n1,n2,n3,n4,allRes=1)
    if (method.rr=="CO")               EST.2     <- opt.CO(r,k.start,b.start,tr,Z,Y,allRes=1)

    if (method.rr=="OP" & altParam==0) out       <- -2*(fL.pap3r(EST.1,x1,x2,x3,n1,n2,n3)-fL.pap3r(c(EST.2,r),x1,x2,x3,n1,n2,n3))
    if (method.rr=="OP" & altParam==1) out       <- -2*(fL.tp3r( EST.1,x1,x2,x3,n1,n2,n3)-fL.tp3r(c( EST.2,r),x1,x2,x3,n1,n2,n3))
    if (method.rr=="TP"              ) out       <- -2*(fL.tp01p02r(EST.1,x1,x2,x3,x4,n1,n2,n3,n4)-fL.tp01p02r(c(EST.2,r),x1,x2,x3,x4,n1,n2,n3,n4))
    if (method.rr=="CO"              ) out       <- -2*(fL.kbr(EST.1,Y,Z,tr)-fL.kbr(c(EST.2,r),Y,Z,tr))
    out
  }

  s           <- length(x1)
  if (method.rr=="OP")               EST.1     <- getEst.OP(init.pa,init.t,init.p3,init.r,x1,x2,x3,n1,n2,n3,altParam,unCond=0,allRes=1)
  if (method.rr=="TP")               EST.1     <- getEst.TP(init.p4,init.tp,init.p3,init.r,x1,x2,x3,x4,n1,n2,n3,n4,allRes=1)
  if (method.rr=="CO")               EST.1     <- getEst.CO(init.k,init.b,init.r,Y,Z,tr,allRes=1)

  if (type=="UB") poss.r <- seq(init.r, init.r+2,by= 0.01)
  if (type=="LB") poss.r <- seq(init.r, init.r-2,by=-0.01)
  npr    <- length(poss.r)
  v      <- matrix(nrow=npr,ncol=1)
  for (i in 1:npr) {
    if (method.rr=="OP" & altParam==0) v[i] <- comp(r=poss.r[i],x1=x1,x2=x2,x3=x3,x4=NA,n1=n1,n2=n2,n3=n3,n4=NA,Y=NA,Z=NA,tr=NA,s=s,EST.1=EST.1,init.pa=init.pa,init.p3=init.p3,init.p4=NA,init.t=NA,init.tp=NA,init.k=NA,init.b=NA,method.rr="OP",altParam=0)
    if (method.rr=="OP" & altParam==1) v[i] <- comp(r=poss.r[i],x1=x1,x2=x2,x3=x3,x4=NA,n1=n1,n2=n2,n3=n3,n4=NA,Y=NA,Z=NA,tr=NA,s=s,EST.1=EST.1,init.pa=NA,init.p3=init.p3,init.p4=NA,init.t=init.t,init.tp=NA,init.k=NA,init.b=NA,method.rr="OP",altParam=1)
    if (method.rr=="TP"              ) v[i] <- comp(r=poss.r[i],x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,Y=NA,Z=NA,tr=NA,s=s,EST.1=EST.1,init.pa=NA,init.p3=init.p3,init.p4=init.p4,init.t=NA,init.tp=init.tp,init.k=NA,init.b=NA,method.rr="TP",altParam=0)
    if (method.rr=="CO"              ) v[i] <- comp(r=poss.r[i],x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,Y=Y,Z=Z,tr=tr,s=s,EST.1=EST.1,init.pa=NA,init.p3=NA,init.p4=NA,init.tp=NA,init.k=init.k,init.b=init.b,method.rr="CO",altParam=0)
  if (abs(v[i]) > qchisq(1-2*alpha2,1)  ) break}
  if (poss.r[i]==init.r+2 | poss.r[i]==init.r-2 ) poss.r[i] <- NA

  poss.r[i]
}



