{
    "collab_server" : "",
    "contents" : "#' Difference in Relative Risks\n#'\n#' This function estimates and provides a confidence interval for the difference between\n#' two relative risks. The first option is there are three populations and the goal to estimate\n#' the difference: p2/p3 - p1/p3, where p1, p2, and p3 are the risks in each population.\n#' The second option is there are four populations and the goal is to estimate the difference:\n#' p2/p4 - p1/p3.\n#'\n#' @import nleqslv\n#' @param x1 The number of events in the first group  (either a single number if there is one strata or a vector if there are multiple strata)\n#' @param x2 The number of events in the second group (either a single number if there is one strata or a vector if there are multiple strata)\n#' @param x3 The number of events in the third group (either a single number if there is one strata or a vector if there are multiple strata)\n#' @param x4 The number of events in the fourth group if the study included four groups (either missing if a three-group study, a single number if there is one strata or a vector if there are multiple strata)\n#' @param n1 The total number of subjects in the first group  (either a single number if there is one strata or a vector if there are multiple strata)\n#' @param n2 The total number of subjects in the second group (either a single number if there is one strata or a vector if there are multiple strata)\n#' @param n3 The total number of subjects in the third group (either a single number if there is one strata or a vector if there are multiple strata)\n#' @param n4 The total number of subjects in the fourth group if the study included four groups (either missing if a three-group study, a single number if there is one strata or a vector if there are multiple strata)\n#' @param alpha The two-sided error rate for the confidence interval (i.e. 0.05 for a 95\\% confidence interval)\n#' @param altParam A binary variable indicating whether a common value of (p1+p2)/p0 should be used when there are multiple strata (only informative when there are three groups and multiple strata)\n#' @param refPop The target population when direct standardization is used (options are \"All\" -- all subjects, \"Treat\" -- treated population, \"Cont\" -- control population; only informative when there are three groups and multiple strata, \"Opt\" -- an optimally chosen population)\n#' @param tr The treatment group for each subject (a vector with one value per subject; values are either 0, 1, or 2; only required if want to adjust for covariates)\n#' @param Y The outcome for each subject (a vector with one value per subject; values are either 0 or 1; only required if want to adjust for covariates)\n#' @param Z The covariates for each subject (a matrix with one value per subject and one column per covariate; only required if want to adjust for covariates)\n#' @param method.rr The method used for calculating the confidence interval (options are \"OP\" - one control group; \"TP\" - two control groups; \"CO\" - covariate adjustment)\n#' @return EST The estimated difference in relative risks\n#' @return LB The lower bound for the difference\n#' @return UB The upper bound for the difference\n#' @return beta The MLE (and asymptotic SE) for the coefficients for individual level covariates (when method.rr=CO)\n#' @examples DRRCI(x1=20,x2=50,x3=100,n1=1000,n2=1000,n3=1000)\n#' @examples #The simplest case where I have three groups and\n#' @examples #want to estimate (50/1000 - 20/1000)/(100/1000)\n#' @examples ##\n#' @examples DRRCI(x1=c(15,5),x2=c(30,20),x3=c(50,50),n1=c(600,400),n2=c(400,600),n3=c(500,500))\n#' @examples #I know have observed individuals in two strata\n#' @examples #here I could use altParam = 1 if I wanted to use the alternative parameterization\n#' @examples #here I could use refPop   = \"All\" (or the other options) if I wanted to use direct standardization\n#' @examples ##\n#' @examples DRRCI(x1=20,x2=50,x3=100,x4=90,n1=1000,n2=1000,n3=1000,n4=90,method.rr=\"TP\")\n#' @examples #I now have a separate \"control\" group for each treatment group; currently, need to set method.rr=\"TP\"\n#' @examples ##\n#' @examples tr = rep(c(0,1,2),each=100)\n#' @examples Y  = c(rep(1,30),rep(0,70),rep(1,10),rep(0,90),rep(1,20),rep(0,80))\n#' @examples Z  = cbind(1,rnorm(300),rnorm(300))\n#' @examples DRRCI(tr=tr,Y=Y,Z=Z,method.rr=\"CO\")\n#' @examples #I now adjust for covariates; currently, need to set method.rr=\"CO\" and let the first column of Z be a vector of 1's\n#' @export\n#'\n\n\nDRRCI <- function(x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,tr=NA,Y=NA,Z=NA,alpha=0.05,altParam=0,refPop=NA,LRT=0,unCond=0){\n\n  method.rr <- \"OP\"\n  if (!is.na(x4[1])) method.rr = \"TP\"\n  if (length(Y)>1)   method.rr = \"CO\"\n\n  if (!is.na(x1[1])  & length(Y) > 1 ) print(\"WARNING: You should not provide BOTH a 2x3 table AND disease/treatment/covariates\")\n  if (!is.na(refPop) & length(Y) > 1 ) print(\"WARNING: You should not provide BOTH a reference population table AND disease/treatment/covariates\")\n  if (length(Y) > 1) {if (length(Z)==length(Y) & sum(Z==1)     != length(Y)) Z <-  cbind(1,Z)\n  if (length(Z)!=length(Y) & sum(Z[,1]==1) != length(Y)) Z <-  cbind(1,Z)\n  if (is.null(colnames(Z))) colnames(Z) <- paste0(\"Z\",c(1:ncol(Z))-1)\n  colnames(Z)[1]=\"Int\"}\n\n  init.pa=init.p3=init.p4=init.t=init.tp=init.k=init.b=NA\n\n  if (method.rr != \"CO\"){\n    if (sum(!is.na(n4))==0) n4 <- rep(0,length(x1))\n    if (sum(!is.na(x4))==0) x4 <- rep(0,length(x1))\n\n    badStrata1 <- c(1:length(n1))[ifelse(n1==0 | n2==0 | n3==0 | (n4==0 & sum(n4)>0),1,0)==1]\n    badStrata2 <- c(1:length(n1))[x3==0]\n    if (altParam==0) badStrata <- sort(unique(c(badStrata1,badStrata2)))\n    if (altParam==1) badStrata <- badStrata1\n    if (length(badStrata) > 0){\n      x1 <- x1[-badStrata]\n      x2 <- x2[-badStrata]\n      x3 <- x3[-badStrata]\n      x4 <- x4[-badStrata]\n      n1 <- n1[-badStrata]\n      n2 <- n2[-badStrata]\n      n3 <- n3[-badStrata]\n      n4 <- n4[-badStrata]\n    }\n\n    if (refPop==\"All\"      & !is.na(refPop))     nR <- n1+n2+n3+n4\n    if (refPop==\"Treat\"    & !is.na(refPop))     nR <- n1+n2\n    if (refPop==\"Cont\"     & !is.na(refPop))     nR <- n3+n4\n    if (refPop==\"Opt\"      & !is.na(refPop) & method.rr==\"OP\")   {\n      p1.hat  <- sum(x1)/sum(n1)\n      p2.hat  <- sum(x2)/sum(n2)\n      p3.hat  <- sum(x3)/sum(n3)\n      pa.hat  <- (p1.hat+p2.hat)/2\n      pie.num <- (pa.hat*(1/n1 + 1/n2) + (0.01+(p1.hat-p2.hat)^2)/(n3*p3.hat))^(-1)\n      pie     <- pie.num/sum(pie.num)\n      nR      <- pie*sum(n1+n2+n3) }\n\n\n    if (refPop==\"Opt\"      & !is.na(refPop) & method.rr==\"TP\")   {\n      print(\"WARNING: The option refPop=Opt does not work for method.rr=TP; Defaults to refPop=All\")\n      nR <- n1+n2+n3+n4}\n\n\n\n    if (!is.na(refPop)){\n      snR <- sum(nR)\n      E1 <- sum((nR/n1)*x1)\n      E2 <- sum((nR/n2)*x2)\n      E3 <- sum((nR/n3)*x3)\n      E4 <- sum((nR/n4)*x4)\n      n1 <- (snR^2)/sum(nR^2/n1)\n      n2 <- (snR^2)/sum(nR^2/n2)\n      n3 <- (snR^2)/sum(nR^2/n3)\n      n4 <- (snR^2)/sum(nR^2/n4)\n      x1 <- n1*E1/snR\n      x2 <- n2*E2/snR\n      x3 <- n3*E3/snR\n      x4 <- n4*E4/snR\n    }\n\n    s <- length(x1)\n    goodStrata <- c(1:s)[(x1+x2+x3+x4>0) & (x1+x2 > 0 | altParam==1 | method.rr!=\"OP\")]\n    if (length(goodStrata) < s) print(\"WARNING: Dropping strata without any events (or events in treatment)\")\n\n    if (s > 1 & length(goodStrata) > 1) {x1 <- x1[goodStrata]\n    x2 <- x2[goodStrata]\n    x3 <- x3[goodStrata]\n    x4 <- x4[goodStrata]\n    n1 <- n1[goodStrata]\n    n2 <- n2[goodStrata]\n    n3 <- n3[goodStrata]\n    n4 <- n4[goodStrata]}\n    s <- length(x1)\n\n\n\n\n    N       <- n1+n2+n3+n4\n    init.pa <- (x1/n1+x2/n2)/2\n    init.pa <- ifelse(init.pa < 0.0001,0.0001,ifelse(init.pa > 0.9999,0.9999,init.pa))\n    init.p3 <-  x3/n3\n    init.p3 <- ifelse(init.p3 < 0.0001,0.0001,ifelse(init.p3 > 0.9999,0.9999,init.p3))\n    init.p4 <-  x4/n4\n    init.tp <-  (x1/n1)/(x3/n3)+(x2/n2)/(x4/n4)\n    init.t  <- sum(N*init.pa)/sum(N*init.p3)\n    tr <- Y <- Z <- NA\n  }\n\n  if (method.rr == \"CO\"){\n    init.b2 <- log(mean(Y[tr==0],na.rm=T))\n    init.b  <- c(ifelse(is.na(init.b2) | init.b2 < -10, -10,init.b2),rep(0,ncol(Z)-1))\n    init.k  <- mean(Y[tr!=0],na.rm=T)/exp(init.b[1])\n    x1 <- x2 <- x3 <- x4 <- n1 <- n2 <- n3 <- n4 <- NA\n  }\n  if (method.rr==\"OP\") init.r  <-  startR.OP(x1,x2,x3,n1,n2,n3)\n  if (method.rr==\"TP\") init.r  <-  startR.TP(x1,x2,x3,x4,n1,n2,n3,n4)\n  if (method.rr==\"CO\") init.r  <-  startR.CO(tr,Z,Y)\n\n  EST <- LB <- UB <- NA\n  if ( (sum(x3)>=2 & (sum(x4)>=2 | sum(n4)==0)) | method.rr == \"CO\" ){\n    if (method.rr==\"OP\") EST <- getEst.OP(init.pa,init.t,init.p3,init.r,x1,x2,x3,n1,n2,n3,altParam,unCond)\n    if (method.rr==\"TP\") EST <- getEst.TP(init.p4,init.tp,init.p3,init.r,x1,x2,x3,x4,n1,n2,n3,n4)\n    if (method.rr==\"CO\") EST <- getEst.CO(init.k,init.b,init.r,Y,Z,tr)\n  }\n  if ( (sum(x3)==0 | (sum(x4)==0 & sum(n4)>0)) &  method.rr != \"CO\")  EST     <- 0\n  if (!is.na(EST) & LRT==0) LB <- boundR(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=alpha/2,type=\"LB\",altParam=altParam,method.rr=method.rr,unCond=unCond)\n  if (!is.na(EST) & LRT==0) UB <- boundR(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=alpha/2,type=\"UB\",altParam=altParam,method.rr=method.rr,unCond=unCond)\n  if (!is.na(EST) & LRT==1) try(LB <- boundR.LRT(init.r,x1,x2,x3,x4,n1,n2,n3,n4,Y,Z,tr,init.pa,init.p3,init.p4,init.t,init.tp,init.k,init.b,method.rr=method.rr,altParam=altParam,alpha2=alpha/2,type=\"LB\"))\n  if (!is.na(EST) & LRT==1) try(UB <- boundR.LRT(init.r,x1,x2,x3,x4,n1,n2,n3,n4,Y,Z,tr,init.pa,init.p3,init.p4,init.t,init.tp,init.k,init.b,method.rr=method.rr,altParam=altParam,alpha2=alpha/2,type=\"UB\"))\n\n  beta               <- NA\n  if (method.rr == \"CO\"){\n    cname              <- colnames(Z)\n    if (length(cname)==0) cname <- rep(\"--\",ncol(Z))\n    bestEst            <- NA\n    try(bestEst           <- getEst.CO(init.k,init.b,init.r,Y,Z,tr,allRes=1))\n    if (length(bestEst) > 1){\n      lbe               <- length(bestEst)\n      III               <- fI.CO(bestEst[lbe],bestEst[1],bestEst[-c(1,lbe)],tr,length(Y),Z)\n      SE                <- rep(NA,lbe)\n      try(SE            <- sqrt(diag(solve(III)))[-c(1,lbe)])\n      betas             <- bestEst[-c(1,lbe)]\n      beta              <- data.frame(\"name\"=cname,\"betas\"=betas,\"SE\"=SE)\n      colnames(beta)    <- c(\"\",\"Beta\",\"SE\")\n    }\n  }\n\n  list(\"EST\"=EST,\"LB\"=LB,\"UB\"=UB,\"beta\"=beta)\n}\n\n\n####################################################################################################################\n#####\n#####Minimization routine runs nleqslv, but uses a wrapper to make the output look like rootSolve\n#####\n####################################################################################################################\n\n\nnleqslv2 <- function(x,fn,...,positive=FALSE) {\n  res <- nleqslv(x,fn,...)\n  res$root   <- ifelse(positive==TRUE & res$x < 0, NA,res$x)\n  res$f.root <- ifelse(positive==TRUE & res$x < 0, 10,res$fvec)\n  res$estim.precis <- sum(abs(res$fvec))\n  res}\n\n\n####################################################################################################################\n#####\n#####Generates Data\n#####\n####################################################################################################################\n\n\n###\n### r = (p2 - p1)/p3\n###\n###Generates a Dataset (3 groups)\n###input:\n###r:                 difference in relative risks\n###pa.s:              average risk in groups w/ drugs\n###p3.s:              average risk in groups w/o drugs\n###n1.s, n2.s, n3.s:  total number of subjects in each of the three groups (to be split among s strata)\n\ngenData.OP   <- function(pa.s,p3.s,r,n1.s,n2.s,n3.s,s=1){\n  if (s>1)  tiltb <- seq(0.67,1.33,length.out=s)\n  if (s==1) tiltb <- 1\n  tilt  <- tiltb/sum(tiltb)\n  r2   <- r/2\n  pa   <- pa.s*tiltb\n  p3   <- p3.s*tiltb\n  p1   <- pa - r2*p3\n  p2   <- pa + r2*p3\n  n1   <- round(n1.s*tilt)\n  n2   <- round(n2.s*rev(tilt))\n  n3   <- round(rep(round(n3.s/s),s))\n  x1   <- rbinom(s,n1,p1)\n  x2   <- rbinom(s,n2,p2)\n  x3   <- rbinom(s,n3,p3)\n  list(\"x1\"=x1,\"x2\"=x2,\"x3\"=x3,\"n1\"=n1,\"n2\"=n2,\"n3\"=n3)\n}\n\n###\n### r = p2/p02 - p1/p01\n### t = p2/p02 + p1/p01\n###\n###Generates a Dataset (4 groups; two control groups)\n###input:\n###r:                           difference in relative risks\n###t:                           sum of vaccine efficacies\n###p01.s, p02.s:                risk in each of the control groups\n###n1.s, n2.s, n01.s, n02.s:    total number of subjects in each of the four groups (to be split among s strata)\n\ngenData.TP   <- function(t.s,r,p01.s,p02.s,n1.s,n2.s,n01.s,n02.s,s=1){\n  t    <- rep(t.s,s)\n  p1   <- rep(p01.s*(t-r)/2,s)\n  p2   <- rep(p02.s*(t+r)/2,s)\n  p01  <- rep(p01.s,s)\n  p02  <- rep(p02.s,s)\n  n1   <- rep(round(n1.s/s),s)\n  n2   <- rep(round(n2.s/s),s)\n  n01  <- rep(round(n01.s/s),s)\n  n02  <- rep(round(n02.s/s),s)\n  x1   <- rbinom(s,n1,p1)\n  x2   <- rbinom(s,n2,p2)\n  x01  <- rbinom(s,n01,p01)\n  x02  <- rbinom(s,n02,p02)\n  list(\"x1\"=x1,\"x2\"=x2,\"x01\"=x01,\"x02\"=x02,\"n1\"=n1,\"n2\"=n2,\"n01\"=n01,\"n02\"=n02)\n}\n\n###\n###p2 = exp(bZ)(k+r/2)\n###p1 = exp(bZ)(k-r/2)\n###p0 = exp(bZ)\n###\n###Generates the outcome (Y), the covariates (Z), the treatment status (tr) for the individuals\n###input:\n###n:         number of subjects\n###r:         (see equation above)\n###k:         (see equation above)\n###b:         a set of coefficients for the covariates\n###\n\ngenData.CO   <- function(r,k,b,n){\n  ncov  <- length(b)-1\n  npg   <- round(n/3)\n  n2    <- 3*npg\n  tr    <- rep(c(0,1,2),each=npg)\n  Z     <- matrix(nrow=n2,ncol=ncov+1)\n  Z[,1] <- matrix(rep(1,n2),ncol=1)\n  for (i in 1:ncov) Z[,i+1]   <- rbinom(n2,1,0.5)\n  p    <- exp(Z%*%b)*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))\n  Y    <- rbinom(n2,1,p)\n  list(\"Z\"=Z,\"Y\"=Y,\"tr\"=tr)\n}\n\n\n####################################################################################################################\n#####\n#####Calculates the negative log-likelihood\n#####\n####################################################################################################################\n\n\n###One Control Group:\n\nfL.OP         <- function(t=NA,pa=NA,p3,r,x1,x2,x3,n1,n2,n3)   {\n  s    <- length(p3)\n  if (sum(!is.na(pa))>0) p1   <- pa   - r*p3/2\n  if (sum(!is.na(pa))>0) p2   <- pa   + r*p3/2\n  if (sum(!is.na(t))>0)  p1   <- t*p3 - r*p3/2\n  if (sum(!is.na(t))>0)  p2   <- t*p3 + r*p3/2\n  out  <- NA\n  if (sum(p1>=0)==s & sum(p2>=0)==s & sum(p3>=0)==s &\n      sum(p1<=1)==s & sum(p2<=1)==s & sum(p3<=1)==s) {p3 <- ifelse(p3==0,0.000001,ifelse(p3==1,0.999999,p3))\n      p1 <- ifelse(p1==0,0.000001,ifelse(p1==1,0.999999,p1))\n      p2 <- ifelse(p2==0,0.000001,ifelse(p2==1,0.999999,p2))\n      out2 <- -(x3*log(p3)+(n3-x3)*log(1-p3)+\n                  x1*log(p1)+(n1-x1)*log(1-p1)+\n                  x2*log(p2)+(n2-x2)*log(1-p2))\n      out  <- sum(out2)}\n  if (abs(out)>9999999999999 | is.na(out)) out <- 9999999999999\n  out}\n\n\n\n###Two Control groups\n\nfL.TP         <- function(t,r,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)   {\n  s    <- length(p01)\n  p1 <- p01*(t-r)/2\n  p2 <- p02*(t+r)/2\n  out  <- NA\n  if (sum(p1>=0)==s & sum(p2>=0)==s & sum(p01>=0)==s & sum(p02>=0)==s &\n      sum(p1<=1)==s & sum(p2<=1)==s & sum(p01<=1)==s & sum(p02<=1)==s) {p01 <- ifelse(p01==0,0.000001,ifelse(p01==1,0.999999,p01))\n      p02 <- ifelse(p02==0,0.000001,ifelse(p02==1,0.999999,p02))\n      p1  <- ifelse(p1==0,0.000001,ifelse(p1==1,0.999999,p1))\n      p2  <- ifelse(p2==0,0.000001,ifelse(p2==1,0.999999,p2))\n      out2 <- -(x02*log(p02)+(n02-x02)*log(1-p02)+\n                  x01*log(p01)+(n01-x01)*log(1-p01)+\n                  x1*log(p1)+(n1-x1)*log(1-p1)+\n                  x2*log(p2)+(n2-x2)*log(1-p2))\n      out  <- sum(out2)}\n  if (abs(out)>9999999999999 | is.na(out)) out <- 9999999999999\n  out}\n\n\n###Individual-level Covarites\n\nfL.CO         <- function(r,k,b,Y,Z,tr){\n  p    <- exp(Z%*%b)*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))\n  p    <- ifelse(p<=0,0.000001,ifelse(p>=1,0.999999,p))\n  out  <- -sum(Y*log(p)+(1-Y)*log(1-p))\n  out\n}\n\n\n\n####################################################################################################################\n#####\n#####Calculates the score equations (i.e. derivative of the log-likelhood)\n#####\n####################################################################################################################\n\n\n\n###One Control Group: Standard Parameterization\n\ndL.OP1<- function(pa,p3,r,x1,x2,x3,n1,n2,n3)   {\n  s   <- length(pa)\n  p1=pa-r*p3/2\n  p2=pa+r*p3/2\n  p1=ifelse(x1>0 & p1==0,0.0001,p1)\n  p2=ifelse(x2>0 & p2==0,0.0001,p2)\n  p3=ifelse(x3>0 & p3==0,0.0001,p3)\n  out.r  <- sum(-x1*(p3/2)/(p1) + (n1-x1)*(p3/2)/(1-p1) +\n                  x2*(p3/2)/(p2) - (n2-x2)*(p3/2)/(1-p2))\n  out.pa <-      x1[1]/p1[1] - (n1[1]-x1[1])/(1-p1[1])  +\n    x2[1]/p2[1] - (n2[1]-x2[1])/(1-p2[1])\n  out.p3 <-      x3[1]/p3[1] - (n3[1]-x3[1])/(1-p3[1])  -  x1[1]*(r/2)/(p1[1]) + (n1[1]-x1[1])*(r/2)/(1-p1[1]) +\n    x2[1]*(r/2)/(p2[1]) - (n2[1]-x2[1])*(r/2)/(1-p2[1])\n  out    <- c(out.r,out.pa,out.p3)\n  if (s > 1) for (i in 2:s) {\n    out.pa <-       x1[i]/p1[i] - (n1[i]-x1[i])/(1-p1[i])  +\n      x2[i]/p2[i] - (n2[i]-x2[i])/(1-p2[i])\n    out.p3 <-       x3[i]/p3[i] - (n3[i]-x3[i])/(1-p3[i])  -  x1[i]*(r/2)/(p1[i]) + (n1[i]-x1[i])*(r/2)/(1-p1[i]) +\n      x2[i]*(r/2)/(p2[i]) - (n2[i]-x2[i])*(r/2)/(1-p2[i])\n    out    <- c(out,out.pa,out.p3)\n\n  }\n  out <- matrix(out,ncol=1)\n  out\n}\n\n###One Control Group: Alternative Parameterization\n\ndL.OP2<- function(t,p3,r,x1,x2,x3,n1,n2,n3)   {\n  s   <- length(p3)\n  p1=(t*p3-r*p3/2)\n  p2=(t*p3+r*p3/2)\n  p1=ifelse(x1>0 & p1==0,0.0001,p1)\n  p2=ifelse(x2>0 & p2==0,0.0001,p2)\n  p3=ifelse(x3>0 & p3==0,0.0001,p3)\n  out.r  <- sum(-x1*p3/(2*p1) + (n1-x1)*p3/(2*(1-p1)) +\n                  x2*p3/(2*p2) - (n2-x2)*p3/(2*(1-p2)) )\n  out.t <-  sum(x1*p3/p1 - (n1-x1)*p3/(1-p1) +\n                  x2*p3/p2 - (n2-x2)*p3/(1-p2) )\n  out.p3 <- x3[1]/p3[1] - (n3[1]-x3[1])/(1-p3[1]) + x1[1]*(t-r/2)/p1[1] - (n1[1]-x1[1])*(t-r/2)/(1-p1[1]) +\n    x2[1]*(t+r/2)/p2[1] - (n2[1]-x2[1])*(t+r/2)/(1-p2[1])\n  out    <- c(out.r,out.t,out.p3)\n  if (s > 1) for (i in 2:s) {\n    out.p3 <-  x3[i]/p3[i] - (n3[i]-x3[i])/(1-p3[i]) + x1[i]*(t-r/2)/p1[i] - (n1[i]-x1[i])*(t-r/2)/(1-p1[i]) +\n      x2[i]*(t+r/2)/p2[i] - (n2[i]-x2[i])*(t+r/2)/(1-p2[i])\n    out    <- c(out,out.p3)\n\n  }\n  out <- matrix(out,ncol=1)\n  out\n}\n\n\n##Two Control Groups:\n\ndL.TP    <- function(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02) {\n  s <- length(p01)\n  p1 <- p01*(t-r)/2\n  p2 <- p02*(t+r)/2\n  p01=ifelse(x01>0 & p01==0,0.0001,p01)\n  p02=ifelse(x02>0 & p02==0,0.0001,p02)\n  p1=ifelse(x1>0 & p1==0,0.0001,p1)\n  p2=ifelse(x2>0 & p2==0,0.0001,p2)\n  q1 <- 1-p1\n  q2 <- 1-p2\n  q01<- 1-p01\n  q02<- 1-p02\n  out.r   <- sum(-x1/(t-r)+(n1-x1)*p01/(2*q1)+x2/(t+r)-(n2-x2)*p02/(2*q2))\n  out.t   <- x1[1]/(t[1]-r)-(n1[1]-x1[1])*p01[1]/(2*q1[1])+x2[1]/(t[1]+r)-(n2[1]-x2[1])*p02[1]/(2*q2[1])\n  out.P01 <- x01[1]/p01[1]-(n01[1]-x01[1])/q01[1]+x1[1]/p01[1]-(n1[1]-x1[1])*(t[1]-r)/(2*q1[1])\n  out.P02 <- x02[1]/p02[1]-(n02[1]-x02[1])/q02[1]+x2[1]/p02[1]-(n2[1]-x2[1])*(t[1]+r)/(2*q2[1])\n  out <- c(out.r,out.t,out.P01,out.P02)\n  if (s > 1) for (i in 2:s){\n    out     <- c(out, x1[i]/(t[i]-r)-(n1[i]-x1[i])*p01[i]/(2*q1[i])+x2[i]/(t[i]+r)-(n2[i]-x2[i])*p02[i]/(2*q2[i]),\n                 x01[i]/p01[i]-(n01[i]-x01[i])/q01[i]+x1[i]/p01[i]-(n1[i]-x1[i])*(t[i]-r)/(2*q1[i]),\n                 x02[i]/p02[i]-(n02[i]-x02[i])/q02[i]+x2[i]/p02[i]-(n2[i]-x2[i])*(t[i]+r)/(2*q2[i]))\n  }\n  matrix(out,ncol=1)\n}\n\n\n####Individual-Level covariates\n\ndL.CO    <- function(r,k,b,tr,n,Z,Y) {\n  nc     <- length(b)\n  ezb    <- exp(Z%*%b)\n  p      <- ezb*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))\n  q      <- 1-p\n  out.r  <- sum((-Y/(2*(k-r/2)) + (1-Y)*ezb /(2*q))*ifelse(tr==1,1,0) +   (Y/(2*(k+r/2)) - (1-Y)*ezb/(2*q))*ifelse(tr==2,1,0))\n  out.k  <- sum( (Y/(  (k-r/2)) - (1-Y)*ezb /(  q))*ifelse(tr==1,1,0) +   (Y/(  (k+r/2)) - (1-Y)*ezb/(  q))*ifelse(tr==2,1,0))\n  out    <- c(out.r,out.k)\n  for (i in 1:nc) out <- c(out,sum(Y*Z[,i]-(1-Y)*Z[,i]*p/q))\n  matrix(out,ncol=1)\n}\n\n\n####################################################################################################################\n#####\n#####Calculates the negative of the information matrices\n#####\n####################################################################################################################\n\n\n###One Control Group: Standard Parameterization\n\nfI.OP1   <- function(pa,p3,r,n1,n2,n3){\n\n  r2 <- r/2\n  p1 <- pa - r2*p3\n  p2 <- pa + r2*p3\n  q1 <- 1-p1\n  q2 <- 1-p2\n  q3 <- 1-p3\n  s  <- length(pa)\n  prob <- 0\n  if(sum(p1<0) > 0 | sum(p1>1) > 0 | sum(p2<0) > 0 | sum(p2>1) > 0) prob <- 1\n  sv <- ifelse(prob==0,0,NA)\n  I      <- matrix(sv,nrow=(2*s+1),ncol=(2*s+1))\n  if (prob==0){\n    I[1,1] <- dL2.RR   <- sum(-(n1*(p3/2)^2)/(p1*q1) - (n2*(p3/2)^2)/(p2*q2))\n    for (i in 1:s){\n      sp <- 2+2*(i-1)\n      ep <- sp + 1\n      I[ep,ep] <- dL2.P3P3 <- -n3[i]/(p3[i]*q3[i]) - n1[i]*r2^2/(p1[i]*q1[i]) - n2[i]*r2^2/(p2[i]*q2[i])\n      I[sp,sp] <- dL2.PAPA <- -n1[i]/(p1[i]*q1[i]) - n2[i]/(p2[i]*q2[i])\n\n      I[sp,ep] <- I[ep,sp] <- dL2.P3PA <-  n1[i]*r2/(p1[i]*q1[i]) - n2[i]*r2/(p2[i]*q2[i])\n      I[1,sp]  <- I[sp,1]  <- dL2.PAR  <-  n1[i]*(p3[i]/2)/(p1[i]*q1[i]) - n2[i]*(p3[i]/2)/(p2[i]*q2[i])\n      I[1,ep]  <- I[ep,1]  <- dL2.P3R  <- -n1[i]*(pa[i]/2)/p1[i] +\n        n1[i]*((1-pa[i])/2)/q1[i] +\n        n2[i]*(pa[i]/2)/p2[i] +\n        -n2[i]*((1-pa[i])/2)/q2[i]\n    }\n  }\n  return(-I)\n}\n\n\n###One Control Group: Alternative Parameterization\n\nfI.OP2   <- function(t,p3,r,n1,n2,n3){\n\n  r2 <- r/2\n  p1 <- t*p3 - r2*p3\n  p2 <- t*p3 + r2*p3\n  q1 <- 1-p1\n  q2 <- 1-p2\n  q3 <- 1-p3\n  s  <- length(p3)\n  prob <- 0\n  if(sum(p1<0) > 0 | sum(p1>1) > 0 | sum(p2<0) > 0 | sum(p2>1) > 0) prob <- 1\n  sv <- ifelse(prob==0,0,NA)\n  I      <- matrix(sv,nrow=(s+2),ncol=(s+2))\n  if (prob==0){\n    I[1,1] <- dL2.RR   <- sum(-(n1*(p3/2)^2)/(p1*q1) - (n2*(p3/2)^2)/(p2*q2))\n    I[2,2] <- dL2.TT   <- sum(-(n1*p3^2)/(p1*q1) - (n2*p3^2)/(p2*q2))\n    I[1,2] <- I[2,1]   <- dL2.TR  <-  sum(n1*p3^2/(2*p1*q1) - n2*p3^2/(2*p2*q2))\n\n    for (i in 1:s){\n      sp <- 2+i\n      I[sp,sp] <- dL2.P3P3 <- -n3[i]/(p3[i]*q3[i]) - n1[i]*(t-r2)^2/(p1[i]*q1[i]) - n2[i]*(t+r2)^2/(p2[i]*q2[i])\n      I[1,sp]  <- I[sp,1]  <- dL2.P3R  <-   n1[i]/(2*q1[i]) - n2[i]/(2*q2[i])\n      I[2,sp]  <- I[sp,2]  <- dL2.P3T  <-  -n1[i]/q1[i]     - n2[i]/q2[i]\n    }\n  }\n  return(-I)\n}\n\n###Two Control Groups:\n\nfI.TP <- function(t,r,p01,p02,n1,n2,n01,n02) {\n  p1 <- p01*(t-r)/2\n  p2 <- p02*(t+r)/2\n  q1 <- 1-p1\n  q2 <- 1-p2\n  q01<- 1-p01\n  q02<- 1-p02\n  s  <- length(p1)\n  prob <- 0\n  if(sum(p1<0) > 0 | sum(p1>1) > 0 | sum(p2<0) > 0 | sum(p2>1) > 0 | sum(p01<0) > 0 | sum(p01>1) > 0 | sum(p02<0) > 0 | sum(p02>1) > 0) prob <- 1\n  sv <- ifelse(prob==0,0,NA)\n  I      <- matrix(sv,nrow=(3*s+1),ncol=(3*s+1))\n  I[1,1]     <- sum(-n1*p01^2/(4*p1*q1) -n2*p02^2/(4*p2*q2))\n  I[2,2]     <-  -n1[1]*p01[1]^2/(4*p1[1]*q1[1]) -n2[1]*p02[1]^2/(4*p2[1]*q2[1])\n  I[3,3]     <- out.P01P01 <- -n01[1]/(p01[1]*q01[1]) - (n1[1]*(t[1]-r)^2)/(4*p1[1]*q1[1])\n  I[4,4]     <- out.P02P02 <- -n02[1]/(p02[1]*q02[1]) - (n1[1]*(t[1]+r)^2)/(4*p2[1]*q2[1])\n  I[1,3]     <- I[3,1]     <- out.P01r  <- n1[1]/(2*q1[1])\n  I[1,4]     <- I[1,4]     <- out.P02r <- -n2[1]/(2*q2[1])\n  I[2,3]     <- I[3,2]     <- out.P01t <- -n1[1]/(2*q1[1])\n  I[2,4]     <- I[4,2]     <- out.P02t <- -n2[1]/(2*q2[1])\n  I[1,2]     <- I[2,1]     <- out.tr     <- n1[1]*p01[1]^2/(4*p1[1]*q1[1]) -n2[1]*p02[1]^2/(4*p2[1]*q2[1])\n  if (s > 1) for (i in 2:s) {\n    sv <- (i-1)*3+2\n    I[sv,sv]     <-  -n1[i]*p01[i]^2/(4*p1[i]*q1[i]) -n2[i]*p02[i]^2/(4*p2[i]*q2[i])\n    I[sv+1,sv+1]     <- out.P01P01 <- -n01[i]/(p01[i]*q01[i]) - (n1[i]*(t[i]-r)^2)/(4*p1[i]*q1[i])\n    I[sv+2,sv+2]     <- out.P02P02 <- -n02[i]/(p02[i]*q02[i]) - (n1[i]*(t[i]+r)^2)/(4*p2[i]*q2[i])\n    I[1,sv+1]     <- I[sv+1,1]     <- out.P01r  <- n1[i]/(2*q1[i])\n    I[1,sv+2]     <- I[sv+2.1]     <- out.P02r <- -n2[i]/(2*q2[i])\n    I[2,sv+1]     <- I[sv+1,2]     <- out.P01t <- -n1[i]/(2*q1[i])\n    I[2,sv+2]     <- I[sv+2,2]     <- out.P02t <- -n2[i]/(2*q2[i])\n    I[1,sv]      <- I[sv,1]     <- out.tr     <- n1[i]*p01[i]^2/(4*p1[i]*q1[i]) -n2[i]*p02[i]^2/(4*p2[i]*q2[i])\n\n  }\n  -I\n}\n\n\n###Individual-level covariates\n\nfI.CO <- function(r,k,b,tr,n,Z) {\n  nc     <- length(b)\n  ezb    <- exp(Z%*%b)\n  ezb2   <- ezb^2\n  p      <- ezb*ifelse(tr==1,k-r/2,ifelse(tr==2,k+r/2,1))\n  q      <- 1-p\n  Zmat   <- matrix(nrow=nc,ncol=nc)\n  I      <- matrix(nrow=(nc+2),ncol=(nc+2))\n  for (i in 1:nc) for (j in 1:nc)  Zmat[i,j] <- sum(-Z[,i]*Z[,j]*p/q)\n  I[-c(1,2),-c(1:2)] <- Zmat\n  I[2,2]  <- sum((-p/(k-r/2)^2 - ezb2/q)*ifelse(tr==1,1,0) + (-p/(k+r/2)^2 - ezb2/q)*ifelse(tr==2,1,0))\n  I[1,1]  <- sum((-p/(4*(k-r/2)^2) - ezb2/(4*q))*ifelse(tr==1,1,0) + (-p/(4*(k+r/2)^2) - ezb2/(4*q))*ifelse(tr==2,1,0))\n  I[1,2]  <- I[2,1] <- sum((p/(2*(k-r/2)^2) + ezb2/(2*q))*ifelse(tr==1,1,0) - (p/(2*(k+r/2)^2) + ezb2/(2*q))*ifelse(tr==2,1,0))\n  for (i in 1:nc) I[1,i+2] <- I[i+2,1] <- sum(  (Z[,i]*ezb/(2*q))*ifelse(tr==1,1,0) - (Z[,i]*ezb/(2*q))*ifelse(tr==2,1,0))\n  for (i in 1:nc) I[2,i+2] <- I[i+2,2] <- -sum( (Z[,i]*ezb/(q))*ifelse(tr==1,1,0)   + (Z[,i]*ezb/(q))*ifelse(tr==2,1,0))\n  -I\n}\n\n\n####################################################################################################################\n#####\n#####Funtions that calculate the log-likelihood or score vectors ... using different formats of input\n#####\n####################################################################################################################\n\n\nfL.pap3r         <- function(pap3r,x1,x2,x3,n1,n2,n3,deriv=0) {s <- length(x1)\npa<- pap3r[1:s]\np3<- pap3r[(s+1):(2*s)]\nr <- pap3r[2*s+1]\nif (deriv==0) out <- fL.OP(NA,pa,p3,r,x1,x2,x3,n1,n2,n3)\nif (deriv==1) out <- dL.OP1(pa,p3,r,x1,x2,x3,n1,n2,n3)\nout\n}\n\n\nfL.pap3         <- function(pap3,x1,x2,x3,n1,n2,n3,r,deriv=0) {s <- length(x1)\npa<- pap3[1:s]\np3<- pap3[(s+1):(2*s)]\nr2=r\nif (deriv==0) out <- fL.OP(NA,pa,p3,r2,x1,x2,x3,n1,n2,n3)\nif (deriv==1) out <- dL.OP1(pa,p3,r2,x1,x2,x3,n1,n2,n3)[-1]\nout\n}\n\n\nfL.pap3.parms <- function(pap3,parms) { s     <- parms[1]\nx1    <- parms[2:(s+1)]\nx2    <- parms[(s+2):(2*s+1)]\nx3    <- parms[(2*s+2):(3*s+1)]\nn1    <- parms[(3*s+2):(4*s+1)]\nn2    <- parms[(4*s+2):(5*s+1)]\nn3    <- parms[(5*s+2):(6*s+1)]\nr     <- parms[(6*s+2)]\nderiv <- parms[(6*s+3)]\nfL.pap3(pap3,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,r=r,deriv=deriv)\n}\n\n\nfL.pap3r.parms <- function(pap3r,parms) { s     <- parms[1]\nx1    <- parms[2:(s+1)]\nx2    <- parms[(s+2):(2*s+1)]\nx3    <- parms[(2*s+2):(3*s+1)]\nn1    <- parms[(3*s+2):(4*s+1)]\nn2    <- parms[(4*s+2):(5*s+1)]\nn3    <- parms[(5*s+2):(6*s+1)]\nderiv <- parms[(6*s+2)]\nfL.pap3r(pap3r,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,deriv=deriv)\n}\n\nfL.pap3r.parms.m5 <- function(pap3r,parms) fL.pap3r.parms(pap3r-c(rep(0,2*parms[1]),5) ,parms)\n\n\nfL.tp3r         <- function(tp3r,x1,x2,x3,n1,n2,n3,deriv=0) {s <- length(x1)\nt <- tp3r[1]\np3<- tp3r[2:(s+1)]\nr <- tp3r[s+2]\nif (deriv==0) out=fL.OP(t,NA,p3,r,x1,x2,x3,n1,n2,n3)\nif (deriv==1) out=dL.OP2(t,p3,r,x1,x2,x3,n1,n2,n3)\nout\n}\n\nfL.tp3         <- function(tp3,x1,x2,x3,n1,n2,n3,r,deriv=0) {s <- length(x1)\nt <- tp3[1]\np3<- tp3[2:(s+1)]\nif (deriv==0) out=fL.OP(t,NA,p3,r,x1,x2,x3,n1,n2,n3)\nif (deriv==1) out=dL.OP2(t,p3,r,x1,x2,x3,n1,n2,n3)[-1]\nout\n}\n\n\nfL.tp3.parms <- function(tp3,parms) { s     <- parms[1]\nx1    <- parms[2:(s+1)]\nx2    <- parms[(s+2):(2*s+1)]\nx3    <- parms[(2*s+2):(3*s+1)]\nn1    <- parms[(3*s+2):(4*s+1)]\nn2    <- parms[(4*s+2):(5*s+1)]\nn3    <- parms[(5*s+2):(6*s+1)]\nr     <- parms[(6*s+2)]\nderiv <- parms[(6*s+3)]\nfL.tp3(tp3,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,r=r,deriv=deriv)\n}\n\n\nfL.tp3r.parms <- function(tp3r,parms) { s     <- parms[1]\nx1    <- parms[2:(s+1)]\nx2    <- parms[(s+2):(2*s+1)]\nx3    <- parms[(2*s+2):(3*s+1)]\nn1    <- parms[(3*s+2):(4*s+1)]\nn2    <- parms[(4*s+2):(5*s+1)]\nn3    <- parms[(5*s+2):(6*s+1)]\nderiv <- parms[(6*s+2)]\nfL.tp3r(tp3r,x1=x1,x2=x2,x3=x3,n1=n1,n2=n2,n3=n3,deriv=deriv)\n}\nfL.tp3r.parms.m5 <- function(tp3r,parms) fL.tp3r.parms(tp3r-c(rep(0,1+parms[1]),5) ,parms)\n\n\n\nfL.tp01p02r         <- function(tp01p02r,x1,x2,x01,x02,n1,n2,n01,n02,deriv=0) {s <- length(x1)\nt  <- tp01p02r[1:s]\np01 <- tp01p02r[(s+1):(2*s)]\np02 <- tp01p02r[(2*s+1):(3*s)]\nr <- tp01p02r[3*s+1]\nif (deriv==0) out <- fL.TP(t,r,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)\nif (deriv==1) out <- dL.TP(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)\nout\n}\n\n\nfL.tp01p02         <- function(tp01p02,x1,x2,x01,x02,n1,n2,n01,n02,r,deriv=0) {s <- length(x1)\nt  <- tp01p02[1:s]\np01 <- tp01p02[(s+1):(2*s)]\np02 <- tp01p02[(2*s+1):(3*s)]\nif (deriv==0) out <- fL.TP(t,r,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)\nif (deriv==1) out <- dL.TP(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)[-1]\nout\n}\n\n\nfL.tp01p02.parms <- function(tp01p02,parms) { s     <- parms[1]\nx1    <- parms[2:(s+1)]\nx2    <- parms[(s+2):(2*s+1)]\nx01    <- parms[(2*s+2):(3*s+1)]\nx02    <- parms[(3*s+2):(4*s+1)]\nn1    <- parms[(4*s+2):(5*s+1)]\nn2    <- parms[(5*s+2):(6*s+1)]\nn01    <- parms[(6*s+2):(7*s+1)]\nn02    <- parms[(7*s+2):(8*s+1)]\nr      <- parms[(8*s+2)]\nderiv <- parms[(8*s+3)]\nfL.tp01p02(tp01p02,x1,x2,x01,x02,n1,n2,n01,n02,r,deriv)\n}\n\n\nfL.tp01p02r.parms <- function(tp01p02r,parms) {  s     <- parms[1]\nx1    <- parms[2:(s+1)]\nx2    <- parms[(s+2):(2*s+1)]\nx01    <- parms[(2*s+2):(3*s+1)]\nx02    <- parms[(3*s+2):(4*s+1)]\nn1    <- parms[(4*s+2):(5*s+1)]\nn2    <- parms[(5*s+2):(6*s+1)]\nn01    <- parms[(6*s+2):(7*s+1)]\nn02    <- parms[(7*s+2):(8*s+1)]\nderiv <- parms[(8*s+2)]\nfL.tp01p02r(tp01p02r,x1,x2,x01,x02,n1,n2,n01,n02,deriv)\n}\nfL.tp01p02r.parms.m5 <- function(tp01p02r,parms) fL.tp01p02r.parms(tp01p02r-c(rep(0,3*parms[1]),5) ,parms)\n\n\n\nfL.kbr         <- function(kbr,Y,Z,tr,deriv=0){\n  k <- kbr[1]\n  b <- kbr[2:(1+ncol(Z))]\n  r <- kbr[(2+ncol(Z))]\n  if (deriv==0) out <- fL.CO(r,k,b,Y,Z,tr)\n  if (deriv==1) out <- dL.CO(r,k,b,tr,n=length(Y),Z,Y)\n  out\n}\n\nfL.kb         <- function(kb,Y,Z,tr,r,deriv=0){\n  k <- kb[1]\n  b <- kb[2:(1+ncol(Z))]\n  if (deriv==0) out <- fL.CO(r,k,b,Y,Z,tr)\n  if (deriv==1) out <- dL.CO(r,k,b,tr,n=length(Y),Z,Y)[-1]\n  out\n}\n\n\nfL.kb.parms <- function(kb,parms) {   n     <- parms[1]\nr     <- parms[2]\nderiv <- parms[3]\nY     <- parms[(4:(n+3))]\ntr    <- parms[(n+4):(2*n+3)]\nZ     <- matrix(parms[-c(1:(2*n+3))],byrow=F,nrow=n)\nfL.kb(kb,Y,Z,tr,r,deriv)\n}\n\n\nfL.kbr.parms <- function(kbr,parms) {   n     <- parms[1]\nderiv <- parms[2]\nY     <- parms[(3:(n+2))]\ntr    <- parms[(n+3):(2*n+2)]\nZ     <- matrix(parms[-c(1:(2*n+2))],byrow=F,nrow=n)\nfL.kbr(kbr,Y,Z,tr,deriv)\n}\n\n\n\n\n####################################################################################################################\n#####\n##### Identifies teh conditional and unconditional MLE\n#####\n####################################################################################################################\n\n\n\noptim.force <-  function(pa=NA,p3=NA,t=NA,r=NA,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr=\"OP\",x1,x2,x3,x4,n1,n2,n3,n4,n,Z,Y,tr,fix.r=0,allRes=0){\n  s              <- length(x1)\n  if (method.rr==\"OP\" & altParam==0)  allParam       <- c(pa,p3,r)\n  if (method.rr==\"OP\" & altParam==1)  allParam       <- c(t,p3,r)\n  if (method.rr==\"CO\")                allParam       <- c(k,b,r)\n  if (method.rr==\"TP\")                allParam       <- c(tp,p3,p4,r)\n\n  if (fix.r==0)  nparam <- length(allParam)\n  if (fix.r==1)  nparam <- length(allParam)-1\n\n  prevMin <- 99999999999\n  mult    <- 1\n  out     <- NA\n  print(\"WARNING: The main function is now identifying the MLE for the liklihood by searching over a grid. This is a time-intensive step.\")\n  print(\"WARNING: If there are a large number of strata (or covariates), this grid search may take > 10-20 minutes.\")\n  for (nattempt in 1:1000){\n    for (curIndex in 1:nparam){\n      if (curIndex <   length(allParam) & method.rr==\"OP\") poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-0.1*mult,0.0001),min(allParam[curIndex]+0.1*mult,0.9999),length.out=10)))\n      if (curIndex ==  length(allParam) & method.rr==\"OP\") poss.vals <- sort(c(allParam[curIndex],seq    (allParam[curIndex]-0.1*mult,            allParam[curIndex]+0.1*mult,        length.out=10)))\n      if (curIndex <   length(allParam) & method.rr==\"TP\") poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-0.1*mult,0.0001),min(allParam[curIndex]+0.1*mult,0.9999),length.out=10)))\n      if (curIndex ==  length(allParam) & method.rr==\"TP\") poss.vals <- sort(c(allParam[curIndex],seq    (allParam[curIndex]-0.1*mult,            allParam[curIndex]+0.1*mult,        length.out=10)))\n\n      if (curIndex ==  1 & method.rr==\"CO\")                {  rrr  <- allParam[length(allParam)]\n      tlb  <- abs(rrr/2)\n      tub  <- min(1/max(exp(Z%*%b)),3)\n      poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-2*mult,tlb),min(allParam[curIndex]+2*mult,tub),length.out=10)))}\n      if (curIndex >  1 & curIndex <   length(allParam) & method.rr==\"CO\")                {  rrr  <- allParam[length(allParam)]\n      kkk  <- allParam[1]\n      bbb  <- allParam[-c(1,curIndex,length(allParam))]\n      ppp  <- exp(Z[,-(curIndex-1)]%*%matrix(bbb,ncol=1))*ifelse(tr==1,kkk-rrr/2,ifelse(tr==2,kkk+rrr/2,1))\n      tlb  <- max(  ifelse(Z[,(curIndex-1)]<0,log(1/ppp)/Z[,(curIndex-1)],-10^10) )\n      tub  <- min(  ifelse(Z[,(curIndex-1)]>0,log(1/ppp)/Z[,(curIndex-1)],10^10) )\n      poss.vals <- sort(c(allParam[curIndex],seq(max(allParam[curIndex]-2*mult,tlb),min(allParam[curIndex]+2*mult,tub),length.out=10)))}\n      if (curIndex ==  length(allParam) & method.rr==\"CO\") poss.vals <- sort(c(allParam[curIndex],seq    (allParam[curIndex]-0.1*mult,            allParam[curIndex]+0.1*mult,        length.out=10)))\n      npv       <- length(poss.vals)\n      func.vals <- matrix(nrow=npv,ncol=1)\n      for (i in 1:npv) {allParam[curIndex]=poss.vals[i]\n      if (method.rr==\"OP\" & altParam==0) func.vals[i] <- fL.OP(NA,allParam[1:s],allParam[(s+1):(2*s)],allParam[2*s+1],x1,x2,x3,n1,n2,n3)\n      if (method.rr==\"OP\" & altParam==1) func.vals[i] <- fL.OP2(allParam[1],NA,allParam[(2):(s+1)],allParam[s+2],x1,x2,x3,n1,n2,n3)\n      if (method.rr==\"CO\")               func.vals[i] <- fL.CO(allParam[length(allParam)],allParam[1],allParam[-c(1,length(allParam))],Y,Z,tr)\n      if (method.rr==\"TP\")               func.vals[i] <- fL.TP(allParam[1:s],allParam[length(allParam)],allParam[(s+1):(2*s)],allParam[(2*s+1):(3*s)],x1,x2,x3,x4,n1,n2,n3,n4)\n      }\n      allParam[curIndex] <-poss.vals[which.min(func.vals)]\n    }\n    if (method.rr==\"OP\" & altParam==0) newMin <- fL.OP(NA,allParam[1:s],allParam[(s+1):(2*s)],allParam[2*s+1],x1,x2,x3,n1,n2,n3)\n    if (method.rr==\"OP\" & altParam==1) newMin <- fL.OP(allParam[1],NA,  allParam[(2):(s+1)],  allParam[s+2],  x1,x2,x3,n1,n2,n3)\n    if (method.rr==\"CO\")               newMin <- fL.CO(allParam[length(allParam)],allParam[1],allParam[-c(1,length(allParam))],Y,Z,tr)\n    if (method.rr==\"TP\")               newMin <- fL.TP(allParam[1:s],allParam[length(allParam)],allParam[(s+1):(2*s)],allParam[(2*s+1):(3*s)],x1,x2,x3,x4,n1,n2,n3,n4)\n    if (newMin==prevMin) mult <- 0.9*mult\n    prevMin <- newMin\n    if (mult < 0.001) break\n  }\n  ok <- ifelse(mult < 0.1,1,0)\n  if (mult < 0.1){\n    if (method.rr==\"OP\" & altParam==0 & allRes==0 & fix.r==0) out <- allParam[2*s+1]\n    if (method.rr==\"OP\" & altParam==0 & allRes==0 & fix.r==1) out <- list(\"pa\"=allParam[1:s],\"p3\"=allParam[(s+1):(2*s)],\"r\"=allParam[2*s+1],\"t\"=NA)\n    if (method.rr==\"OP\" & altParam==1 & allRes==0 & fix.r==0) out <- allParam[s+2]\n    if (method.rr==\"OP\" & altParam==1 & allRes==0 & fix.r==1) out <- list(\"pa\"=NA,           \"p3\"=allParam[(2):(s+1)],  \"r\"=allParam[s+2],  \"t\"=allParam[1])\n    if (method.rr==\"CO\"               & allRes==0 & fix.r==0) out <- allParam[length(allParam)]\n    if (method.rr==\"CO\"               & allRes==0 & fix.r==1) out <- list(\"r\"=allParam[length(allParam)],\"k\"=allParam[1],\"b\"=allParam[-c(1,length(allParam))])\n    if (method.rr==\"TP\"               & allRes==0 & fix.r==0) out <- allParam[length(allParam)]\n    if (method.rr==\"TP\"               & allRes==0 & fix.r==1) out <- list(\"tp\"=allParam[1:s],\"r\"=allParam[length(allParam)],\"p3\"=allParam[(s+1):(2*s)],\"p4\"=allParam[(2*s+1):(3*s)])\n\n\n    if (method.rr==\"OP\" & altParam==0 & allRes==1 & fix.r==1) out <- c(allParam[1:s],allParam[(s+1):(2*s)])\n    if (method.rr==\"OP\" & altParam==0 & allRes==1 & fix.r==0) out <- c(allParam[1:s],allParam[(s+1):(2*s)],allParam[2*s+1])\n    if (method.rr==\"OP\" & altParam==1 & allRes==1 & fix.r==1) out <- c(allParam[1],allParam[(2):(s+1)])\n    if (method.rr==\"OP\" & altParam==1 & allRes==1 & fix.r==0) out <- c(allParam[1],allParam[(2):(s+1)],allParam[s+2])\n    if (method.rr==\"CO\"               & allRes==1 & fix.r==1) out <- allParam[-length(allParam)]\n    if (method.rr==\"CO\"               & allRes==1 & fix.r==0) out <- allParam\n    if (method.rr==\"TP\"               & allRes==1 & fix.r==1) out <- allParam[-length(allParam)]\n    if (method.rr==\"TP\"               & allRes==1 & fix.r==0) out <- allParam\n\n  }\n  list(\"out\"=out,\"ok\"=ok)\n}\n\n\n\noptim.ideal <- function(pa=NA,p3=NA,t=NA,r=NA,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr=\"OP\",x1,x2,x3,x4,n1,n2,n3,n4,n,Z,Y,tr,fix.r=0,allRes=0){\n  s      <- length(x1)\n  r.out  <- r\n  t.out  <- NA\n  pa.out <- rep(NA,s)\n  p3.out <- rep(NA,s)\n  k.out  <- NA\n  b.out  <- rep(NA,length(b))\n  p4.out <- rep(NA,s)\n  tp.out <- rep(NA,s)\n  EST    <- NA\n  out    <- NA\n  ll.end <- 99999999999\n  ok <- 1\n\n  if (method.rr==\"OP\" & altParam==0){\n\n    if (fix.r==1){\n      for (sss in 1:s){\n        resb     <- nleqslv2(x=c(pa[sss],p3[sss]),fn=fL.pap3.parms,parms=c(1,x1[sss],x2[sss],x3[sss],n1[sss],n2[sss],n3[sss],r,1),positive=TRUE)\n        ll.start <- fL.pap3.parms(c(pa[sss],p3[sss]),parms=c(1,x1[sss],x2[sss],x3[sss],n1[sss],n2[sss],n3[sss],r,0))\n        try(ll.end   <- fL.pap3.parms(resb$root,         parms=c(1,x1[sss],x2[sss],x3[sss],n1[sss],n2[sss],n3[sss],r,0)),silent=TRUE)\n        if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0\n        if (ok==1) pa.out[sss]  <- resb$root[1]\n        if (ok==1) p3.out[sss]  <- resb$root[2]\n        if (ok==1)             out <- list(\"pa\"=pa.out,\"p3\"=p3.out)\n        if (ok==1 & allRes==1) out <- c(pa.out,p3.out)\n      }\n    }\n\n    if (fix.r==0){\n      resb      <- nleqslv2(x=c(pa,p3,r+5),fn=fL.pap3r.parms.m5,parms=c(length(x1),x1,x2,x3,n1,n2,n3,1),positive=TRUE)\n      ll.start  <- fL.pap3r.parms.m5(c(pa,p3,r+5),parms=c(length(x1),x1,x2,x3,n1,n2,n3,0))\n      try(ll.end    <- fL.pap3r.parms.m5(resb$root,   parms=c(length(x1),x1,x2,x3,n1,n2,n3,0)),silent=TRUE)\n      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0\n      if (ok==1)             out  <- resb$root[2*s+1] -5\n      if (allRes==1 & ok==1) out  <- resb$root - c(rep(0,2*s),5)\n    }\n\n  }\n\n\n  if (method.rr==\"OP\" & altParam==1){\n\n    if (fix.r==1){\n      resb     <- nleqslv2(x=c(t,p3),fn=fL.tp3.parms,parms=c(s,x1,x2,x3,n1,n2,n3,r,1),positive=TRUE)\n      ll.start <- fL.tp3.parms(c(t,p3),  parms=c(s,x1,x2,x3,n1,n2,n3,r,0))\n      try(ll.end   <- fL.tp3.parms(resb$root,parms=c(s,x1,x2,x3,n1,n2,n3,r,0)),silent=TRUE)\n      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0\n      if (ok==1) t.out   <- resb$root[1]\n      if (ok==1) p3.out  <- resb$root[-1]\n      if (ok==1)             out <- list(\"t\"=t.out,\"p3\"=p3.out)\n      if (ok==1 & allRes==1) out <- c(t.out,p3.out)\n    }\n\n    if (fix.r==0){\n      resb      <- nleqslv2(x=c(t,p3,r+5),fn=fL.tp3r.parms.m5,parms=c(length(x1),x1,x2,x3,n1,n2,n3,1),positive=TRUE)\n      ll.start  <- fL.tp3r.parms.m5(c(t,p3,r+5),parms=c(length(x1),x1,x2,x3,n1,n2,n3,0))\n      try(ll.end    <- fL.tp3r.parms.m5(resb$root,   parms=c(length(x1),x1,x2,x3,n1,n2,n3,0)),silent=TRUE)\n      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0\n      if (ok==1)             out  <- resb$root[s+2]-5\n      if (allRes==1 & ok==1) out <- resb$root - c(rep(0,s+1),5)\n    }\n\n  }\n\n\n  if (method.rr==\"CO\"){\n\n    if (fix.r==1){\n      resb     <- nleqslv2(x=c(k,b),fn=fL.kb.parms,parms=c(length(Y),r,1,Y,tr,c(Z)))\n      ll.start <- fL.kb.parms(c(k,b),  parms=c(length(Y),r,0,Y,tr,c(Z)))\n      try(ll.end   <- fL.kb.parms(resb$root,parms=c(length(Y),r,0,Y,tr,c(Z))),silent=TRUE)\n      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0\n      if (ok==1) k.out   <- resb$root[1]\n      if (ok==1) b.out  <- resb$root[-1]\n      if (ok==1)             out <- list(\"k\"=k.out,\"b\"=b.out)\n      if (ok==1 & allRes==1) out <- c(k.out,b.out)\n    }\n\n    if (fix.r==0){\n      resb      <- nleqslv2(x=c(k,b,r),fn=fL.kbr.parms,parms=c(length(Y),1,Y,tr,c(Z)))\n      ll.start  <- fL.kbr.parms(c(k,b,r),parms=c(length(Y),0,Y,tr,c(Z)))\n      try(ll.end    <- fL.kbr.parms(resb$root,   parms=c(length(Y),0,Y,tr,c(Z))),silent=TRUE)\n      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0\n      if (ok==1)             out  <- resb$root[length(c(k,b))+1]\n      if (allRes==1 & ok==1) out <- resb$root\n    }\n\n  }\n\n  if (method.rr==\"TP\"){\n\n    if (fix.r==1){\n      for (sss in 1:s){\n        resb     <- nleqslv2(x=c(tp[sss],p3[sss],p4[sss]),fn=fL.tp01p02.parms,parms=c(1,x1[sss],x2[sss],x3[sss],x4[sss],n1[sss],n2[sss],n3[sss],n4[sss],r,1),positive=TRUE)\n        ll.start <- fL.tp01p02.parms(c(tp[sss],p3[sss],p4[sss]),parms=c(1,x1[sss],x2[sss],x3[sss],x4[sss],n1[sss],n2[sss],n3[sss],n4[sss],r,0))\n        try(ll.end   <- fL.tp01p02.parms(resb$root,         parms=c(1,x1[sss],x2[sss],x3[sss],x4[sss],n1[sss],n2[sss],n3[sss],n4[sss],r,0)),silent=TRUE)\n        if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start)) ok <- 0\n        if (ok==1) tp.out[sss]  <- resb$root[1]\n        if (ok==1) p3.out[sss]  <- resb$root[2]\n        if (ok==1) p4.out[sss]  <- resb$root[3]\n        if (ok==1)             out <- list(\"tp\"=tp.out,\"p3\"=p3.out,\"p4.out\"=p4.out)\n        if (ok==1 & allRes==1) out <- c(tp.out,p3.out,p4.out)\n      }\n    }\n\n    if (fix.r==0){\n      resb      <- nleqslv2(x=c(tp,p3,p4,r+5),fn=fL.tp01p02r.parms.m5,parms=c(length(x1),x1,x2,x3,x4,n1,n2,n3,n4,1),positive=TRUE)\n      ll.start  <- fL.tp01p02r.parms.m5(c(tp,p3,p4,r+5),parms=c(length(x1),x1,x2,x3,x4,n1,n2,n3,n4,0))\n      try(ll.end    <- fL.tp01p02r.parms.m5(resb$root,   parms=c(length(x1),x1,x2,x3,x4,n1,n2,n3,n4,0)),silent=TRUE)\n      if ((sum(resb$f.root>0.01)>1) | sum(is.na(resb$f.root))>0 | (ll.end>ll.start) )ok <- 0\n      if (ok==1)             out  <- resb$root[3*s+1] -5\n      if (allRes==1 & ok==1) out  <- resb$root - c(rep(0,3*s),5)\n    }\n\n  }\n\n\n  list(\"out\"=out,\"ok\"=ok)\n}\n\noptim.DSS <- function(pa=NA,p3=NA,t=NA,r=NA,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr=\"OP\",x1,x2,x3,x4,n1,n2,n3,n4,n,Z,Y,tr,fix.r=0,allRes=0){\n  optim.out <- optim.ideal(pa=pa,p3=p3,t=t,r=r,k=k,b=b,p4=p4,tp=tp,altParam=altParam,method.rr=method.rr,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,n=n,Z=Z,Y=Y,tr=tr,fix.r=fix.r,allRes=allRes)\n  if (optim.out$ok==0) optim.out <- optim.force(pa=pa,p3=p3,t=t,r=r,k=k,b=b,p4=p4,tp=tp,altParam=altParam,method.rr=method.rr,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,n=n,Z=Z,Y=Y,tr=tr,fix.r=fix.r,allRes=allRes)\n  optim.out$out\n}\n\n\n\n####################################################################################################################\n#####\n##### Wrapper functions for finding the conditional MLE\n#####\n####################################################################################################################\n\n\n\nopt.OP1 <- function(r,pa.start,p3.start,x1,x2,x3,n1,n2,n3,forceRoot=0,allRes=0){\n  optim.DSS(pa=pa.start,p3=p3.start,t=NA,r=r,k=NA,b=NA,p4=NA,tp=NA,altParam=0,method.rr=\"OP\",x1,x2,x3,x4=rep(0,length(x3)),n1,n2,n3,n4=rep(0,length(x3)),n=NA,Z=NA,Y=NA,tr=NA,fix.r=1,allRes=allRes)\n}\n\n\nopt.OP2 <- function(r,t.start,p3.start,x1,x2,x3,n1,n2,n3,forceRoot=0,allRes=0){\n  optim.DSS(pa=NA,p3=p3.start,t=t.start,r=r,k=NA,b=NA,p4=NA,tp=NA,altParam=1,method.rr=\"OP\",x1,x2,x3,x4=rep(0,length(x3)),n1,n2,n3,n4=rep(0,length(x3)),n=NA,Z=NA,Y=NA,tr=NA,fix.r=1,allRes=allRes)\n}\n\n\nopt.TP <- function(r,t.start,p01.start,p02.start,x1,x2,x01,x02,n1,n2,n01,n02,allRes=0){\n  optim.DSS(pa=NA,p3=p01.start,t=NA,r=r,k=NA,b=NA,p4=p02.start,tp=t.start,altParam=0,method.rr=\"TP\",x1,x2,x01,x02,n1,n2,n01,n02,n=NA,Z=NA,Y=NA,tr=NA,fix.r=1,allRes=allRes)\n}\n\n\n\nopt.CO <- function(r,k.start,b.start,tr,Z,Y,allRes=0){\n  optim.DSS(pa=NA,p3=NA,t=NA,r=r,k=k.start,b=b.start,p4=NA,tp=NA,altParam=0,method.rr=\"CO\",NA,NA,NA,NA,NA,NA,NA,NA,n=length(Y),Z=Z,Y=Y,tr=tr,fix.r=1,allRes=allRes)\n}\n\n\n\n\n####################################################################################################################\n#####\n#####Wrapper function for getting the uncondition MLE of r\n#####\n####################################################################################################################\n\n\ngetEst.OP <- function(init.pa=NA,init.t=NA,init.p3,init.r,x1,x2,x3,n1,n2,n3,altParam=0,unCond=0,allRes=0,forceRoot=0){\n  optim.DSS(pa=init.pa,p3=init.p3,t=init.t,r=init.r,k=NA,b=NA,p4=NA,tp=NA,altParam=altParam,method.rr=\"OP\",x1,x2,x3,x4=rep(0,length(x3)),n1,n2,n3,n4=rep(0,length(x3)),n=NA,Z=NA,Y=NA,tr=NA,fix.r=0,allRes=allRes)\n}\n\ngetEst.TP <- function(init.p4,init.tp,init.p3,init.r,x1,x2,x3,x4,n1,n2,n3,n4,allRes=0){\n  optim.DSS(pa=NA,p3=init.p3,t=NA,r=init.r,k=NA,b=NA,p4=init.p4,tp=init.tp,altParam=0,method.rr=\"TP\",x1,x2,x3,x4,n1,n2,n3,n4,n=NA,Z=NA,Y=NA,tr=NA,fix.r=0,allRes=allRes)\n}\n\n\ngetEst.CO <- function(init.k,init.b,init.r,Y,Z,tr,allRes=0){\n  optim.DSS(pa=NA,p3=NA,t=NA,r=init.r,k=init.k,b=init.b,p4=NA,tp=NA,altParam=0,method.rr=\"CO\",NA,NA,NA,NA,NA,NA,NA,NA,n=length(Y),Z=Z,Y=Y,tr=tr,fix.r=0,allRes=allRes)\n}\n\n\n####################################################################################################################\n#####\n#####Calculates the Z statistic for a given set of values\n#####\n####################################################################################################################\n\n\ngetZ2.OP1 <- function(pa,p3,r,x1,x2,x3,n1,n2,n3,unCond=0){\n  I   <- fI.OP1(pa,p3,r,n1,n2,n3)\n  dL  <- dL.OP1(pa,p3,r,x1,x2,x3,n1,n2,n3)\n  Z   <- -9999999\n  if (!is.na(I[1,1])){\n    si  <- solve(I[-1,-1])\n    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]\n    if (unCond==1) v   <- I[1,1]\n    if (v>0 & unCond==0)  Z   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)\n    if (v>0 & unCond==1)  Z   <- (dL[1])/sqrt(v)\n  }\n  Z\n}\n\ngetZ2.OP2 <- function(t,p3,r,x1,x2,x3,n1,n2,n3,unCond=0){\n  I   <- fI.OP2(t,p3,r,n1,n2,n3)\n  dL  <- dL.OP2(t,p3,r,x1,x2,x3,n1,n2,n3)\n  Z   <- -9999999\n  if (!is.na(I[1,1])){\n    si  <- solve(I[-1,-1])\n    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]\n    if (unCond==1) v   <- I[1,1]\n    if (v>0 & unCond==0)  Z   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)\n    if (v>0 & unCond==1)  Z   <- (dL[1])/sqrt(v)\n  }\n  Z\n}\n\ngetZ2.TP <- function(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02,unCond=0){\n  I   <- fI.TP(t,r,p01,p02,n1,n2,n01,n02)\n  dL  <- dL.TP(r,t,p01,p02,x1,x2,x01,x02,n1,n2,n01,n02)\n  Z   <- -9999999\n  if (!is.na(I[1,1])){\n    si  <- solve(I[-1,-1])\n    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]\n    if (unCond==1) v   <- I[1,1]\n    if (v>0 & unCond==0)  Z   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)\n    if (v>0 & unCond==1)  Z   <- (dL[1])/sqrt(v)\n  }\n  Z\n}\n\ngetZ2.CO <- function(r,k,b,tr,Z,Y,unCond=0) {\n  n <- length(Y)\n  I   <- fI.CO(r,k,b,tr,n,Z)\n  dL  <- dL.CO(r,k,b,tr,n,Z,Y)\n  Z2   <- -9999999\n  if (!is.na(I[1,1])){\n    si  <- solve(I[-1,-1])\n    if (unCond==0) v   <- I[1,1]-I[1,-1]%*%si%*%I[-1,1]\n    if (unCond==1) v   <- I[1,1]\n    if (v>0 & unCond==0)  Z2   <- (dL[1]- I[1,-1]%*%si%*%dL[-1])/sqrt(v)\n    if (v>0 & unCond==1)  Z2   <- (dL[1])/sqrt(v)\n  }\n  Z2\n}\n\n\n####################################################################################################################\n#####\n#####Calculates Z values for a given value r (using MLE of other parameters)\n#####\n####################################################################################################################\n\n\ngetZ.OP1 <- function(r,x1,x2,x3,n1,n2,n3,unCond=0,forceRoot=0){\n  sv  <- startVals.OP(x1,x2,x3,n1,n2,n3,r)\n  sv2 <- opt.OP1(r,sv$pa,sv$p3,x1,x2,x3,n1,n2,n3,forceRoot=forceRoot)\n  getZ2.OP1(sv2$pa,sv2$p3,r,x1,x2,x3,n1,n2,n3,unCond)\n}\n\n\ngetZ.OP2 <- function(r,x1,x2,x3,n1,n2,n3,unCond=0,forceRoot=0){\n  sv  <- startVals.OP(x1,x2,x3,n1,n2,n3,r)\n  sv2 <- opt.OP2(r,sv$t,sv$p3,x1,x2,x3,n1,n2,n3,forceRoot=forceRoot)\n  getZ2.OP2(sv2$t,sv2$p3,r,x1,x2,x3,n1,n2,n3,unCond)\n}\n\ngetZ.TP <- function(r,x1,x2,x01,x02,n1,n2,n01,n02,unCond=0){\n  sv  <- startVals.TP(x1,x2,x01,x02,n1,n2,n01,n02,r)\n  sv2 <- opt.TP(r,sv$t,sv$p01,sv$p02,x1,x2,x01,x02,n1,n2,n01,n02)\n  getZ2.TP(r,sv2$t,sv2$p01,sv2$p02,x1,x2,x01,x02,n1,n2,n01,n02,unCond)\n}\n\ngetZ.CO <- function(r,tr,Z,Y,unCond=0){\n  sv  <- startVals.CO(r,tr,Z,Y)\n  sv2 <- opt.CO(r,sv$k,sv$b,tr,Z,Y)\n  getZ2.CO(r,sv2$k,sv2$b,tr,Z,Y,unCond)\n}\n\ngetZ.OP <- function(r,x1,x2,x3,n1,n2,n3,altParam=0,unCond=0,forceRoot=0){\n  if (altParam==0) Z <- getZ.OP1(r,x1,x2,x3,n1,n2,n3,unCond,forceRoot=forceRoot)\n  if (altParam==1) Z <- getZ.OP2(r,x1,x2,x3,n1,n2,n3,unCond,forceRoot=forceRoot)\n  Z\n}\n\n\n\n####################################################################################################################\n#####\n#####Gets good starting values for the nuicance parametyers given a specified value of r\n#####\n####################################################################################################################\n\n\n####Given a specific value of r, generate a set of starting values for the MLE for pa and p3\n####\nstartVals2.OP <- function(x1,x2,x3,n1,n2,n3,r){\n  if (x1+x2+x3==0) x3 <- x3+1\n  d0 <- r*(x3/n3)\n  L1 <- (x1*d0-n1-n2-2*x1)*d0+x1+x2\n  L2 <- (n1+n2+x1)*d0-n1-n2-x1-x2\n  L3 <- n1+n2\n  L0 <- x1*d0*(1-d0)\n  C  <- L2^3/(27*L3^3)-L1*L2/(6*L3^2)+L0/(2*L3)\n  B  <- sign(C)*sqrt(L2^2/(9*L3^2)-L1/(3*L3))\n  A  <- (1/3)*(pi+acos(C/B^3))\n  p1.t <- 2*B*cos(A)-L2/(3*L3)\n  p2.t <- p1.t+d0\n  pa=(p1.t+p2.t)/2\n  p3=x3/n3\n  p3 <- ifelse(p3<0.0001,0.0001,p3)\n  if (pa < 0) pa <- (x1+x2)/(n1+n2)\n  t=pa/p3\n  list(\"pa\"=pa,\"p3\"=p3,\"t\"=t)\n}\n\nstartVals.OP <- function(x1,x2,x3,n1,n2,n3,r){\n  s  <- length(x1)\n  sv <- startVals2.OP(x1[1],x2[1],x3[1],n1[1],n2[1],n3[1],r)\n  pa <- sv$pa\n  p3 <- sv$p3\n  if (s > 1) for (i in 2:s) { sv <- startVals2.OP(x1[i],x2[i],x3[i],n1[i],n2[i],n3[i],r)\n  pa <- c(pa,sv$pa)\n  p3 <- c(p3,sv$p3)}\n  p3 <- ifelse(p3<0.0001,0.0001,p3)\n  p1 <- pa - (r/2)*p3\n  p2 <- pa + (r/2)*p3\n\n  thresh.p <- 0.00001\n  thresh.p2<- 0.99999\n\n  p1 <- ifelse(p1 < thresh.p,thresh.p,p1)\n  p2 <- ifelse(p1==thresh.p,p1 + r*p3,p2)\n  p2 <- ifelse(p2 < thresh.p,thresh.p,p2)\n  p1 <- ifelse(p2==thresh.p,p2 - r*p3,p1)\n\n  p1 <- ifelse(p1 > thresh.p2,thresh.p2,p1)\n  p2 <- ifelse(p1==thresh.p2, p1 + r*p3,p2)\n  p2 <- ifelse(p2 > thresh.p2,thresh.p2,p2)\n  p1 <- ifelse(p2==thresh.p2, p2 - r*p3,p1)\n  pa <- (p1 + p2)/2\n\n  N <- n1+n2+n3\n  t <- sum(N*((pa-p3*r/2 + pa+p3*r/2 )/2))/sum(N*p3)\n\n\n  list(\"pa\"=pa,\"p3\"=p3,\"t\"=t)\n}\n\n\nstartVals.TP <- function(x1,x2,x01,x02,n1,n2,n01,n02,r){\n  sv <- startVals.OP(x1,x2,x3=(x01+x02),n1,n2,n3=(n01+n02),r)\n  pcomb <- (x01+x02)/(n01+n02)\n  p2 <- (sv$pa+r*sv$p3/2) * ((x02/n02)/pcomb)\n  p1 <- (sv$pa-r*sv$p3/2) * ((x01/n01)/pcomb)\n  p01 <- (x01/n01)\n  p02 <- (x02/n02)\n  t   <- p1/p01+p2/p02\n  list(\"p01\"=p01,\"p02\"=p02,\"t\"=t)\n}\n\nstartVals.CO <- function(r,tr,Z,Y){\n  sv <- -10\n  if (sum(Y[tr==0])>0) sv <- log(sum(Y[tr==0])/sum(tr==0))\n  b <- c(sv,rep(0,ncol(Z)-1))\n  k <- (sum(Y[tr!=0])/sum(tr!=0))/(sum(Y[tr==0])/sum(tr==0))\n  list(\"k\"=k,\"b\"=b)\n}\n\n\n####################################################################################################################\n#####\n#####Identifies good starting values of r\n#####\n####################################################################################################################\n\n\nstartR.OP <- function(x1,x2,x3,n1,n2,n3){\n  ###Option 1: Taylor Series Expansion\n  p1       <- sum(x1)/sum(n1) + 0.00001\n  p2       <- sum(x2)/sum(n2) + 0.00001\n  p3       <- sum(x3)/sum(n3) + 0.00001\n  v        <- (p1*(1-p1)/n1 + p2*(1-p2)/n2)/p3^2 + ((p1-p2)^2/(p3^4))*(p3*(1-p3)/n3)\n  v2       <- 0.25*(1/p3)^4*(p3*(1-p3)/n3)*p1*(1-p1)/n1 + 0.25*(1/p3)^4*(p3*(1-p3)/n3)*p2*(1-p2)/n2 + (1/p3)^6*((p1-p2)^2)*2*(p3*(1-p3)/n3)^2\n  v3       <- v + v2\n  rs       <- ((x2+0.5/n2)/(n2+0.5/n2) - (x1+0.5/n1)/(n1+0.5/n1))/((x3+0.5/n3)/(n3+0.5/n3))\n  out      <- sum(rs[x3>0]/v3[x3>0])/sum(1/v3[x3>0])\n  if (is.na(out)) out <- 0\n  out\n}\n\nstartR.TP <- function(x1,x2,x3,x4,n1,n2,n3,n4){\n  ###Option 1: Taylor Series Expansion\n  p1       <- sum(x1)/sum(n1) + 0.00001\n  p2       <- sum(x2)/sum(n2) + 0.00001\n  p3       <- sum(x3)/sum(n3) + 0.00001\n  p4       <- sum(x4)/sum(n4) + 0.00001\n  v        <- (p1*(1-p1)/n1)/p3^2 + (p2*(1-p2)/n2)/p4^2 + (p1^2/p3^4)*(p3*(1-p3)/n3) + (p2^2/p4^4)*(p4*(1-p4)/n4)\n  rs       <- ((x2+0.5/n2)/(n2+0.5/n2))/((x4+0.5/n4)/(n4+0.5/n4)) - ((x1+0.5/n1)/(n1+0.5/n1))/((x3+0.5/n3)/(n3+0.5/n3))\n  out      <- sum(rs[x3>0]/v[x3>0])/sum(1/v[x3>0])\n  if (is.na(out)) out <- 0\n  out\n}\n\nstartR.CO <- function(tr,Z,Y){\n  p1 <- mean(Y[tr==1],na.rm=T)\n  p2 <- mean(Y[tr==2],na.rm=T)\n  p3 <- mean(Y[tr==0],na.rm=T)\n  out <- (p2-p1)/p3\n  if (is.na(out) | p3==0) out <- 0\n  out\n}\n\n\n####################################################################################################################\n#####\n##### Identifies the bounds for the score-based confidence intervals\n#####\n####################################################################################################################\n\n\n####Find the value of r that gives a z statistic that equals qnorm(alpha2) or qnorm(1-alpha2)\n####\nfindR.int <- function(r,alpha2,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,altParam=0,method.rr=\"OP\",unCond=0)    {if (method.rr==\"OP\") out <- abs(    abs(getZ.OP(r,x1,x2,x3,n1,n2,n3,altParam,unCond,forceRoot=1)) - abs(qnorm(alpha2))  )\nif (method.rr==\"TP\") out <- abs(    abs(getZ.TP(r,x1,x2,x3,x4,n1,n2,n3,n4,unCond,forceRoot=1))    - abs(qnorm(alpha2))  )\nif (method.rr==\"CO\") out <- abs(    abs(getZ.CO(r,tr,Z,Y,unCond))    - abs(qnorm(alpha2))  )\nout}\n\nboundR2    <- function(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=0.025,type=\"UB\",altParam=0,method.rr=\"OP\",unCond=0)   {\n  if (type==\"UB\") min.r    <- EST+0.001\n  if (type==\"UB\") max.r    <- EST+2\n  if (type==\"UB\") start.r  <- min.r\n  if (type==\"UB\") last.r   <- max.r\n  if (type==\"LB\") min.r    <- EST-2\n  if (type==\"LB\") max.r    <- EST-0.001\n  if (type==\"LB\") start.r  <- max.r\n  if (type==\"LB\") last.r   <- min.r\n  poss.r  <- seq(start.r,last.r,by=ifelse(type==\"LB\",-1,1)*0.01)\n  poss.d  <- matrix(NA,ncol=1,nrow=length(poss.r))\n  for (i in 1:length(poss.r)) {\n    aaa=try(poss.d[i] <- findR.int(r=poss.r[i],alpha2=alpha2,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,tr=tr,Z=Z,Y=Y,altParam=altParam,method.rr=method.rr,unCond=unCond),silent=TRUE)\n    if (i > 1) if ((poss.d[i] > poss.d[i-1] & poss.d[i] < 1) | is.na(poss.d[i]) | class(aaa) == \"try-error\") break\n  }\n  reachMax <- ifelse(i==length(poss.r),1,0)\n  poss.r   <- seq(poss.r[i-1],poss.r[i],by=ifelse(type==\"LB\",-1,1)*0.001)\n  poss.d   <- matrix(ncol=1,nrow=length(poss.r))\n  for (i in 1:length(poss.r)) {\n    aaa=try(poss.d[i] <- findR.int(r=poss.r[i],alpha2=alpha2,x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,tr=tr,Z=Z,Y=Y,altParam=altParam,method.rr=method.rr,unCond=unCond),silent=TRUE)\n    if (i > 1) if (poss.d[i] > poss.d[i-1] | is.na(poss.d[i]) | class(aaa) == \"try-error\") break\n  }\n  out <- ifelse(reachMax==1 | poss.d[i-1] > 0.1,NA,poss.r[i])\n  out}\n\n\nboundR    <- function(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=0.025,type=\"UB\",altParam=0,method.rr=\"TP\",unCond=0)  {\n  out <- boundR2(EST,x1,x2,x3,x4,n1,n2,n3,n4,tr,Z,Y,alpha2=alpha2,type=type,altParam=altParam,method.rr=method.rr,unCond=unCond)\n  out\n}\n\n####################################################################################################################\n#####\n##### Identifies the bounds for the likelihood-based confidence intervals\n#####\n####################################################################################################################\n\n\nboundR.LRT <- function(init.r=NA,x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,Y=NA,Z=NA,tr=NA,init.pa=NA,init.p3=NA,init.p4=NA,init.t=NA,init.tp=NA,init.k=NA,init.b=NA,method.rr=\"OP\",altParam=0,alpha2=alpha/2,type=\"LB\"){\n\n\n  comp        <- function(r=NA,x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,Y=NA,Z=NA,tr=NA,s=NA,EST.1=NA,init.pa=NA,init.p3=NA,init.p4=NA,init.t=NA,init.tp=NA,init.k=NA,init.b=NA,method.rr=\"OP\",altParam=0) {\n    if (method.rr==\"OP\" & altParam==0) EST.2     <- opt.OP1(r,init.pa,init.p3,x1,x2,x3,n1,n2,n3,forceRoot=1,allRes=1)\n    if (method.rr==\"OP\" & altParam==1) EST.2     <- opt.OP2(r,init.t,init.p3,x1,x2,x3,n1,n2,n3,forceRoot=1,allRes=1)\n    if (method.rr==\"TP\")               EST.2     <- opt.TP(r,init.t,init.p3,init.p4,x1,x2,x3,x4,n1,n2,n3,n4,allRes=1)\n    if (method.rr==\"CO\")               EST.2     <- opt.CO(r,k.start,b.start,tr,Z,Y,allRes=1)\n\n    if (method.rr==\"OP\" & altParam==0) out       <- -2*(fL.pap3r(EST.1,x1,x2,x3,n1,n2,n3)-fL.pap3r(c(EST.2,r),x1,x2,x3,n1,n2,n3))\n    if (method.rr==\"OP\" & altParam==1) out       <- -2*(fL.tp3r( EST.1,x1,x2,x3,n1,n2,n3)-fL.tp3r(c( EST.2,r),x1,x2,x3,n1,n2,n3))\n    if (method.rr==\"TP\"              ) out       <- -2*(fL.tp01p02r(EST.1,x1,x2,x3,x4,n1,n2,n3,n4)-fL.tp01p02r(c(EST.2,r),x1,x2,x3,x4,n1,n2,n3,n4))\n    if (method.rr==\"CO\"              ) out       <- -2*(fL.kbr(EST.1,Y,Z,tr)-fL.kbr(c(EST.2,r),Y,Z,tr))\n    out\n  }\n\n  s           <- length(x1)\n  if (method.rr==\"OP\")               EST.1     <- getEst.OP(init.pa,init.t,init.p3,init.r,x1,x2,x3,n1,n2,n3,altParam,unCond=0,allRes=1)\n  if (method.rr==\"TP\")               EST.1     <- getEst.TP(init.p4,init.tp,init.p3,init.r,x1,x2,x3,x4,n1,n2,n3,n4,allRes=1)\n  if (method.rr==\"CO\")               EST.1     <- getEst.CO(init.k,init.b,init.r,Y,Z,tr,allRes=1)\n\n  if (type==\"UB\") poss.r <- seq(init.r, init.r+2,by= 0.01)\n  if (type==\"LB\") poss.r <- seq(init.r, init.r-2,by=-0.01)\n  npr    <- length(poss.r)\n  v      <- matrix(nrow=npr,ncol=1)\n  for (i in 1:npr) {\n    if (method.rr==\"OP\" & altParam==0) v[i] <- comp(r=poss.r[i],x1=x1,x2=x2,x3=x3,x4=NA,n1=n1,n2=n2,n3=n3,n4=NA,Y=NA,Z=NA,tr=NA,s=s,EST.1=EST.1,init.pa=init.pa,init.p3=init.p3,init.p4=NA,init.t=NA,init.tp=NA,init.k=NA,init.b=NA,method.rr=\"OP\",altParam=0)\n    if (method.rr==\"OP\" & altParam==1) v[i] <- comp(r=poss.r[i],x1=x1,x2=x2,x3=x3,x4=NA,n1=n1,n2=n2,n3=n3,n4=NA,Y=NA,Z=NA,tr=NA,s=s,EST.1=EST.1,init.pa=NA,init.p3=init.p3,init.p4=NA,init.t=init.t,init.tp=NA,init.k=NA,init.b=NA,method.rr=\"OP\",altParam=1)\n    if (method.rr==\"TP\"              ) v[i] <- comp(r=poss.r[i],x1=x1,x2=x2,x3=x3,x4=x4,n1=n1,n2=n2,n3=n3,n4=n4,Y=NA,Z=NA,tr=NA,s=s,EST.1=EST.1,init.pa=NA,init.p3=init.p3,init.p4=init.p4,init.t=NA,init.tp=init.tp,init.k=NA,init.b=NA,method.rr=\"TP\",altParam=0)\n    if (method.rr==\"CO\"              ) v[i] <- comp(r=poss.r[i],x1=NA,x2=NA,x3=NA,x4=NA,n1=NA,n2=NA,n3=NA,n4=NA,Y=Y,Z=Z,tr=tr,s=s,EST.1=EST.1,init.pa=NA,init.p3=NA,init.p4=NA,init.tp=NA,init.k=init.k,init.b=init.b,method.rr=\"CO\",altParam=0)\n    if (abs(v[i]) > qchisq(1-2*alpha2,1)  ) break}\n  if (poss.r[i]==init.r+2 | poss.r[i]==init.r-2 ) poss.r[i] <- NA\n\n  poss.r[i]\n}\n\n\n\n",
    "created" : 1536022904295.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3030738839",
    "id" : "43E4951D",
    "lastKnownWriteTime" : 1536022969,
    "last_content_update" : 1536022970089,
    "path" : "~/Projects/HPV/India/DiffRelRisk/R/DiffRelRisk.R",
    "project_path" : "R/DiffRelRisk.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}